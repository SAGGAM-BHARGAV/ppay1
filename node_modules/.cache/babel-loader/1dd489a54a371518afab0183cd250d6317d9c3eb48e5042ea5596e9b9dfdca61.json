{"ast":null,"code":"import { _optionalChain } from '@sentry/utils';\nimport { defineIntegration, convertIntegrationFnToClass, getClient } from '@sentry/core';\nimport { LRUMap, logger } from '@sentry/utils';\nimport { NODE_VERSION } from '../../nodeVersion.js';\nimport { createRateLimiter, hashFromStack, hashFrames, functionNamesMatch } from './common.js';\n\n/* eslint-disable max-lines */\n\n/** Creates a container for callbacks to be called sequentially */\nfunction createCallbackList(complete) {\n  // A collection of callbacks to be executed last to first\n  let callbacks = [];\n  let completedCalled = false;\n  function checkedComplete(result) {\n    callbacks = [];\n    if (completedCalled) {\n      return;\n    }\n    completedCalled = true;\n    complete(result);\n  }\n\n  // complete should be called last\n  callbacks.push(checkedComplete);\n  function add(fn) {\n    callbacks.push(fn);\n  }\n  function next(result) {\n    const popped = callbacks.pop() || checkedComplete;\n    try {\n      popped(result);\n    } catch (_) {\n      // If there is an error, we still want to call the complete callback\n      checkedComplete(result);\n    }\n  }\n  return {\n    add,\n    next\n  };\n}\n\n/**\n * Promise API is available as `Experimental` and in Node 19 only.\n *\n * Callback-based API is `Stable` since v14 and `Experimental` since v8.\n * Because of that, we are creating our own `AsyncSession` class.\n *\n * https://nodejs.org/docs/latest-v19.x/api/inspector.html#promises-api\n * https://nodejs.org/docs/latest-v14.x/api/inspector.html\n */\nclass AsyncSession {\n  /** Throws if inspector API is not available */\n  constructor() {\n    /*\n    TODO: We really should get rid of this require statement below for a couple of reasons:\n    1. It makes the integration unusable in the SvelteKit SDK, as it's not possible to use `require`\n       in SvelteKit server code (at least not by default).\n    2. Throwing in a constructor is bad practice\n     More context for a future attempt to fix this:\n    We already tried replacing it with import but didn't get it to work because of async problems.\n    We still called import in the constructor but assigned to a promise which we \"awaited\" in\n    `configureAndConnect`. However, this broke the Node integration tests as no local variables\n    were reported any more. We probably missed a place where we need to await the promise, too.\n    */\n\n    // Node can be built without inspector support so this can throw\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const {\n      Session\n    } = require('inspector');\n    this._session = new Session();\n  }\n\n  /** @inheritdoc */\n  configureAndConnect(onPause, captureAll) {\n    this._session.connect();\n    this._session.on('Debugger.paused', event => {\n      onPause(event, () => {\n        // After the pause work is complete, resume execution or the exception context memory is leaked\n        this._session.post('Debugger.resume');\n      });\n    });\n    this._session.post('Debugger.enable');\n    this._session.post('Debugger.setPauseOnExceptions', {\n      state: captureAll ? 'all' : 'uncaught'\n    });\n  }\n  setPauseOnExceptions(captureAll) {\n    this._session.post('Debugger.setPauseOnExceptions', {\n      state: captureAll ? 'all' : 'uncaught'\n    });\n  }\n\n  /** @inheritdoc */\n  getLocalVariables(objectId, complete) {\n    this._getProperties(objectId, props => {\n      const {\n        add,\n        next\n      } = createCallbackList(complete);\n      for (const prop of props) {\n        if (_optionalChain([prop, 'optionalAccess', _2 => _2.value, 'optionalAccess', _3 => _3.objectId]) && _optionalChain([prop, 'optionalAccess', _4 => _4.value, 'access', _5 => _5.className]) === 'Array') {\n          const id = prop.value.objectId;\n          add(vars => this._unrollArray(id, prop.name, vars, next));\n        } else if (_optionalChain([prop, 'optionalAccess', _6 => _6.value, 'optionalAccess', _7 => _7.objectId]) && _optionalChain([prop, 'optionalAccess', _8 => _8.value, 'optionalAccess', _9 => _9.className]) === 'Object') {\n          const id = prop.value.objectId;\n          add(vars => this._unrollObject(id, prop.name, vars, next));\n        } else if (_optionalChain([prop, 'optionalAccess', _10 => _10.value, 'optionalAccess', _11 => _11.value]) != null || _optionalChain([prop, 'optionalAccess', _12 => _12.value, 'optionalAccess', _13 => _13.description]) != null) {\n          add(vars => this._unrollOther(prop, vars, next));\n        }\n      }\n      next({});\n    });\n  }\n\n  /**\n   * Gets all the PropertyDescriptors of an object\n   */\n  _getProperties(objectId, next) {\n    this._session.post('Runtime.getProperties', {\n      objectId,\n      ownProperties: true\n    }, (err, params) => {\n      if (err) {\n        next([]);\n      } else {\n        next(params.result);\n      }\n    });\n  }\n\n  /**\n   * Unrolls an array property\n   */\n  _unrollArray(objectId, name, vars, next) {\n    this._getProperties(objectId, props => {\n      vars[name] = props.filter(v => v.name !== 'length' && !isNaN(parseInt(v.name, 10))).sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10)).map(v => _optionalChain([v, 'optionalAccess', _14 => _14.value, 'optionalAccess', _15 => _15.value]));\n      next(vars);\n    });\n  }\n\n  /**\n   * Unrolls an object property\n   */\n  _unrollObject(objectId, name, vars, next) {\n    this._getProperties(objectId, props => {\n      vars[name] = props.map(v => [v.name, _optionalChain([v, 'optionalAccess', _16 => _16.value, 'optionalAccess', _17 => _17.value])]).reduce((obj, [key, val]) => {\n        obj[key] = val;\n        return obj;\n      }, {});\n      next(vars);\n    });\n  }\n\n  /**\n   * Unrolls other properties\n   */\n  _unrollOther(prop, vars, next) {\n    if (_optionalChain([prop, 'optionalAccess', _18 => _18.value, 'optionalAccess', _19 => _19.value]) != null) {\n      vars[prop.name] = prop.value.value;\n    } else if (_optionalChain([prop, 'optionalAccess', _20 => _20.value, 'optionalAccess', _21 => _21.description]) != null && _optionalChain([prop, 'optionalAccess', _22 => _22.value, 'optionalAccess', _23 => _23.type]) !== 'function') {\n      vars[prop.name] = `<${prop.value.description}>`;\n    }\n    next(vars);\n  }\n}\n\n/**\n * When using Vercel pkg, the inspector module is not available.\n * https://github.com/getsentry/sentry-javascript/issues/6769\n */\nfunction tryNewAsyncSession() {\n  try {\n    return new AsyncSession();\n  } catch (e) {\n    return undefined;\n  }\n}\nconst INTEGRATION_NAME = 'LocalVariables';\n\n/**\n * Adds local variables to exception frames\n */\nconst _localVariablesSyncIntegration = (options = {}, session = tryNewAsyncSession()) => {\n  const cachedFrames = new LRUMap(20);\n  let rateLimiter;\n  let shouldProcessEvent = false;\n  function handlePaused(stackParser, {\n    params: {\n      reason,\n      data,\n      callFrames\n    }\n  }, complete) {\n    if (reason !== 'exception' && reason !== 'promiseRejection') {\n      complete();\n      return;\n    }\n    _optionalChain([rateLimiter, 'optionalCall', _24 => _24()]);\n\n    // data.description contains the original error.stack\n    const exceptionHash = hashFromStack(stackParser, _optionalChain([data, 'optionalAccess', _25 => _25.description]));\n    if (exceptionHash == undefined) {\n      complete();\n      return;\n    }\n    const {\n      add,\n      next\n    } = createCallbackList(frames => {\n      cachedFrames.set(exceptionHash, frames);\n      complete();\n    });\n\n    // Because we're queuing up and making all these calls synchronously, we can potentially overflow the stack\n    // For this reason we only attempt to get local variables for the first 5 frames\n    for (let i = 0; i < Math.min(callFrames.length, 5); i++) {\n      const {\n        scopeChain,\n        functionName,\n        this: obj\n      } = callFrames[i];\n      const localScope = scopeChain.find(scope => scope.type === 'local');\n\n      // obj.className is undefined in ESM modules\n      const fn = obj.className === 'global' || !obj.className ? functionName : `${obj.className}.${functionName}`;\n      if (_optionalChain([localScope, 'optionalAccess', _26 => _26.object, 'access', _27 => _27.objectId]) === undefined) {\n        add(frames => {\n          frames[i] = {\n            function: fn\n          };\n          next(frames);\n        });\n      } else {\n        const id = localScope.object.objectId;\n        add(frames => _optionalChain([session, 'optionalAccess', _28 => _28.getLocalVariables, 'call', _29 => _29(id, vars => {\n          frames[i] = {\n            function: fn,\n            vars\n          };\n          next(frames);\n        })]));\n      }\n    }\n    next([]);\n  }\n  function addLocalVariablesToException(exception) {\n    const hash = hashFrames(_optionalChain([exception, 'optionalAccess', _30 => _30.stacktrace, 'optionalAccess', _31 => _31.frames]));\n    if (hash === undefined) {\n      return;\n    }\n\n    // Check if we have local variables for an exception that matches the hash\n    // remove is identical to get but also removes the entry from the cache\n    const cachedFrame = cachedFrames.remove(hash);\n    if (cachedFrame === undefined) {\n      return;\n    }\n\n    // Filter out frames where the function name is `new Promise` since these are in the error.stack frames\n    // but do not appear in the debugger call frames\n    const frames = (_optionalChain([exception, 'access', _32 => _32.stacktrace, 'optionalAccess', _33 => _33.frames]) || []).filter(frame => frame.function !== 'new Promise');\n    for (let i = 0; i < frames.length; i++) {\n      // Sentry frames are in reverse order\n      const frameIndex = frames.length - i - 1;\n\n      // Drop out if we run out of frames to match up\n      if (!frames[frameIndex] || !cachedFrame[i]) {\n        break;\n      }\n      if (\n      // We need to have vars to add\n      cachedFrame[i].vars === undefined ||\n      // We're not interested in frames that are not in_app because the vars are not relevant\n      frames[frameIndex].in_app === false ||\n      // The function names need to match\n      !functionNamesMatch(frames[frameIndex].function, cachedFrame[i].function)) {\n        continue;\n      }\n      frames[frameIndex].vars = cachedFrame[i].vars;\n    }\n  }\n  function addLocalVariablesToEvent(event) {\n    for (const exception of _optionalChain([event, 'optionalAccess', _34 => _34.exception, 'optionalAccess', _35 => _35.values]) || []) {\n      addLocalVariablesToException(exception);\n    }\n    return event;\n  }\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      const client = getClient();\n      const clientOptions = _optionalChain([client, 'optionalAccess', _36 => _36.getOptions, 'call', _37 => _37()]);\n      if (session && _optionalChain([clientOptions, 'optionalAccess', _38 => _38.includeLocalVariables])) {\n        // Only setup this integration if the Node version is >= v18\n        // https://github.com/getsentry/sentry-javascript/issues/7697\n        const unsupportedNodeVersion = NODE_VERSION.major < 18;\n        if (unsupportedNodeVersion) {\n          logger.log('The `LocalVariables` integration is only supported on Node >= v18.');\n          return;\n        }\n        const captureAll = options.captureAllExceptions !== false;\n        session.configureAndConnect((ev, complete) => handlePaused(clientOptions.stackParser, ev, complete), captureAll);\n        if (captureAll) {\n          const max = options.maxExceptionsPerSecond || 50;\n          rateLimiter = createRateLimiter(max, () => {\n            logger.log('Local variables rate-limit lifted.');\n            _optionalChain([session, 'optionalAccess', _39 => _39.setPauseOnExceptions, 'call', _40 => _40(true)]);\n          }, seconds => {\n            logger.log(`Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`);\n            _optionalChain([session, 'optionalAccess', _41 => _41.setPauseOnExceptions, 'call', _42 => _42(false)]);\n          });\n        }\n        shouldProcessEvent = true;\n      }\n    },\n    processEvent(event) {\n      if (shouldProcessEvent) {\n        return addLocalVariablesToEvent(event);\n      }\n      return event;\n    },\n    // These are entirely for testing\n    _getCachedFramesCount() {\n      return cachedFrames.size;\n    },\n    _getFirstCachedFrame() {\n      return cachedFrames.values()[0];\n    }\n  };\n};\nconst localVariablesSyncIntegration = defineIntegration(_localVariablesSyncIntegration);\n\n/**\n * Adds local variables to exception frames.\n * @deprecated Use `localVariablesSyncIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst LocalVariablesSync = convertIntegrationFnToClass(INTEGRATION_NAME, localVariablesSyncIntegration);\n\n// eslint-disable-next-line deprecation/deprecation\n\nexport { LocalVariablesSync, createCallbackList, localVariablesSyncIntegration };","map":{"version":3,"names":["createCallbackList","complete","callbacks","completedCalled","checkedComplete","result","push","add","fn","next","popped","pop","_","AsyncSession","constructor","Session","require","_session","configureAndConnect","onPause","captureAll","connect","on","event","post","state","setPauseOnExceptions","getLocalVariables","objectId","_getProperties","props","prop","_optionalChain","_2","value","_3","_4","_5","className","id","vars","_unrollArray","name","_6","_7","_8","_9","_unrollObject","_10","_11","_12","_13","description","_unrollOther","ownProperties","err","params","filter","v","isNaN","parseInt","sort","a","b","map","_14","_15","_16","_17","reduce","obj","key","val","_18","_19","_20","_21","_22","_23","type","tryNewAsyncSession","e","undefined","INTEGRATION_NAME","_localVariablesSyncIntegration","options","session","cachedFrames","LRUMap","rateLimiter","shouldProcessEvent","handlePaused","stackParser","reason","data","callFrames","_24","exceptionHash","hashFromStack","_25","frames","set","i","Math","min","length","scopeChain","functionName","this","localScope","find","scope","_26","object","_27","function","_28","_29","addLocalVariablesToException","exception","hash","hashFrames","_30","stacktrace","_31","cachedFrame","remove","_32","_33","frame","frameIndex","in_app","functionNamesMatch","addLocalVariablesToEvent","_34","_35","values","setupOnce","client","getClient","clientOptions","_36","getOptions","_37","_38","includeLocalVariables","unsupportedNodeVersion","NODE_VERSION","major","logger","log","captureAllExceptions","ev","max","maxExceptionsPerSecond","createRateLimiter","_39","_40","seconds","_41","_42","processEvent","_getCachedFramesCount","size","_getFirstCachedFrame","localVariablesSyncIntegration","defineIntegration","LocalVariablesSync","convertIntegrationFnToClass"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\integrations\\local-variables\\local-variables-sync.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { convertIntegrationFnToClass, defineIntegration, getClient } from '@sentry/core';\nimport type { Event, Exception, Integration, IntegrationClass, IntegrationFn, StackParser } from '@sentry/types';\nimport { LRUMap, logger } from '@sentry/utils';\nimport type { Debugger, InspectorNotification, Runtime, Session } from 'inspector';\nimport type { NodeClient } from '../../client';\n\nimport { NODE_VERSION } from '../../nodeVersion';\nimport type {\n  FrameVariables,\n  LocalVariablesIntegrationOptions,\n  PausedExceptionEvent,\n  RateLimitIncrement,\n  Variables,\n} from './common';\nimport { createRateLimiter, functionNamesMatch, hashFrames, hashFromStack } from './common';\n\ntype OnPauseEvent = InspectorNotification<Debugger.PausedEventDataType>;\nexport interface DebugSession {\n  /** Configures and connects to the debug session */\n  configureAndConnect(onPause: (message: OnPauseEvent, complete: () => void) => void, captureAll: boolean): void;\n  /** Updates which kind of exceptions to capture */\n  setPauseOnExceptions(captureAll: boolean): void;\n  /** Gets local variables for an objectId */\n  getLocalVariables(objectId: string, callback: (vars: Variables) => void): void;\n}\n\ntype Next<T> = (result: T) => void;\ntype Add<T> = (fn: Next<T>) => void;\ntype CallbackWrapper<T> = { add: Add<T>; next: Next<T> };\n\n/** Creates a container for callbacks to be called sequentially */\nexport function createCallbackList<T>(complete: Next<T>): CallbackWrapper<T> {\n  // A collection of callbacks to be executed last to first\n  let callbacks: Next<T>[] = [];\n\n  let completedCalled = false;\n  function checkedComplete(result: T): void {\n    callbacks = [];\n    if (completedCalled) {\n      return;\n    }\n    completedCalled = true;\n    complete(result);\n  }\n\n  // complete should be called last\n  callbacks.push(checkedComplete);\n\n  function add(fn: Next<T>): void {\n    callbacks.push(fn);\n  }\n\n  function next(result: T): void {\n    const popped = callbacks.pop() || checkedComplete;\n\n    try {\n      popped(result);\n    } catch (_) {\n      // If there is an error, we still want to call the complete callback\n      checkedComplete(result);\n    }\n  }\n\n  return { add, next };\n}\n\n/**\n * Promise API is available as `Experimental` and in Node 19 only.\n *\n * Callback-based API is `Stable` since v14 and `Experimental` since v8.\n * Because of that, we are creating our own `AsyncSession` class.\n *\n * https://nodejs.org/docs/latest-v19.x/api/inspector.html#promises-api\n * https://nodejs.org/docs/latest-v14.x/api/inspector.html\n */\nclass AsyncSession implements DebugSession {\n  private readonly _session: Session;\n\n  /** Throws if inspector API is not available */\n  public constructor() {\n    /*\n    TODO: We really should get rid of this require statement below for a couple of reasons:\n    1. It makes the integration unusable in the SvelteKit SDK, as it's not possible to use `require`\n       in SvelteKit server code (at least not by default).\n    2. Throwing in a constructor is bad practice\n\n    More context for a future attempt to fix this:\n    We already tried replacing it with import but didn't get it to work because of async problems.\n    We still called import in the constructor but assigned to a promise which we \"awaited\" in\n    `configureAndConnect`. However, this broke the Node integration tests as no local variables\n    were reported any more. We probably missed a place where we need to await the promise, too.\n    */\n\n    // Node can be built without inspector support so this can throw\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { Session } = require('inspector');\n    this._session = new Session();\n  }\n\n  /** @inheritdoc */\n  public configureAndConnect(onPause: (event: OnPauseEvent, complete: () => void) => void, captureAll: boolean): void {\n    this._session.connect();\n\n    this._session.on('Debugger.paused', event => {\n      onPause(event, () => {\n        // After the pause work is complete, resume execution or the exception context memory is leaked\n        this._session.post('Debugger.resume');\n      });\n    });\n\n    this._session.post('Debugger.enable');\n    this._session.post('Debugger.setPauseOnExceptions', { state: captureAll ? 'all' : 'uncaught' });\n  }\n\n  public setPauseOnExceptions(captureAll: boolean): void {\n    this._session.post('Debugger.setPauseOnExceptions', { state: captureAll ? 'all' : 'uncaught' });\n  }\n\n  /** @inheritdoc */\n  public getLocalVariables(objectId: string, complete: (vars: Variables) => void): void {\n    this._getProperties(objectId, props => {\n      const { add, next } = createCallbackList<Variables>(complete);\n\n      for (const prop of props) {\n        if (prop?.value?.objectId && prop?.value.className === 'Array') {\n          const id = prop.value.objectId;\n          add(vars => this._unrollArray(id, prop.name, vars, next));\n        } else if (prop?.value?.objectId && prop?.value?.className === 'Object') {\n          const id = prop.value.objectId;\n          add(vars => this._unrollObject(id, prop.name, vars, next));\n        } else if (prop?.value?.value != null || prop?.value?.description != null) {\n          add(vars => this._unrollOther(prop, vars, next));\n        }\n      }\n\n      next({});\n    });\n  }\n\n  /**\n   * Gets all the PropertyDescriptors of an object\n   */\n  private _getProperties(objectId: string, next: (result: Runtime.PropertyDescriptor[]) => void): void {\n    this._session.post(\n      'Runtime.getProperties',\n      {\n        objectId,\n        ownProperties: true,\n      },\n      (err, params) => {\n        if (err) {\n          next([]);\n        } else {\n          next(params.result);\n        }\n      },\n    );\n  }\n\n  /**\n   * Unrolls an array property\n   */\n  private _unrollArray(objectId: string, name: string, vars: Variables, next: (vars: Variables) => void): void {\n    this._getProperties(objectId, props => {\n      vars[name] = props\n        .filter(v => v.name !== 'length' && !isNaN(parseInt(v.name, 10)))\n        .sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10))\n        .map(v => v?.value?.value);\n\n      next(vars);\n    });\n  }\n\n  /**\n   * Unrolls an object property\n   */\n  private _unrollObject(objectId: string, name: string, vars: Variables, next: (obj: Variables) => void): void {\n    this._getProperties(objectId, props => {\n      vars[name] = props\n        .map<[string, unknown]>(v => [v.name, v?.value?.value])\n        .reduce((obj, [key, val]) => {\n          obj[key] = val;\n          return obj;\n        }, {} as Variables);\n\n      next(vars);\n    });\n  }\n\n  /**\n   * Unrolls other properties\n   */\n  private _unrollOther(prop: Runtime.PropertyDescriptor, vars: Variables, next: (vars: Variables) => void): void {\n    if (prop?.value?.value != null) {\n      vars[prop.name] = prop.value.value;\n    } else if (prop?.value?.description != null && prop?.value?.type !== 'function') {\n      vars[prop.name] = `<${prop.value.description}>`;\n    }\n\n    next(vars);\n  }\n}\n\n/**\n * When using Vercel pkg, the inspector module is not available.\n * https://github.com/getsentry/sentry-javascript/issues/6769\n */\nfunction tryNewAsyncSession(): AsyncSession | undefined {\n  try {\n    return new AsyncSession();\n  } catch (e) {\n    return undefined;\n  }\n}\n\nconst INTEGRATION_NAME = 'LocalVariables';\n\n/**\n * Adds local variables to exception frames\n */\nconst _localVariablesSyncIntegration = ((\n  options: LocalVariablesIntegrationOptions = {},\n  session: DebugSession | undefined = tryNewAsyncSession(),\n) => {\n  const cachedFrames: LRUMap<string, FrameVariables[]> = new LRUMap(20);\n  let rateLimiter: RateLimitIncrement | undefined;\n  let shouldProcessEvent = false;\n\n  function handlePaused(\n    stackParser: StackParser,\n    { params: { reason, data, callFrames } }: InspectorNotification<PausedExceptionEvent>,\n    complete: () => void,\n  ): void {\n    if (reason !== 'exception' && reason !== 'promiseRejection') {\n      complete();\n      return;\n    }\n\n    rateLimiter?.();\n\n    // data.description contains the original error.stack\n    const exceptionHash = hashFromStack(stackParser, data?.description);\n\n    if (exceptionHash == undefined) {\n      complete();\n      return;\n    }\n\n    const { add, next } = createCallbackList<FrameVariables[]>(frames => {\n      cachedFrames.set(exceptionHash, frames);\n      complete();\n    });\n\n    // Because we're queuing up and making all these calls synchronously, we can potentially overflow the stack\n    // For this reason we only attempt to get local variables for the first 5 frames\n    for (let i = 0; i < Math.min(callFrames.length, 5); i++) {\n      const { scopeChain, functionName, this: obj } = callFrames[i];\n\n      const localScope = scopeChain.find(scope => scope.type === 'local');\n\n      // obj.className is undefined in ESM modules\n      const fn = obj.className === 'global' || !obj.className ? functionName : `${obj.className}.${functionName}`;\n\n      if (localScope?.object.objectId === undefined) {\n        add(frames => {\n          frames[i] = { function: fn };\n          next(frames);\n        });\n      } else {\n        const id = localScope.object.objectId;\n        add(frames =>\n          session?.getLocalVariables(id, vars => {\n            frames[i] = { function: fn, vars };\n            next(frames);\n          }),\n        );\n      }\n    }\n\n    next([]);\n  }\n\n  function addLocalVariablesToException(exception: Exception): void {\n    const hash = hashFrames(exception?.stacktrace?.frames);\n\n    if (hash === undefined) {\n      return;\n    }\n\n    // Check if we have local variables for an exception that matches the hash\n    // remove is identical to get but also removes the entry from the cache\n    const cachedFrame = cachedFrames.remove(hash);\n\n    if (cachedFrame === undefined) {\n      return;\n    }\n\n    // Filter out frames where the function name is `new Promise` since these are in the error.stack frames\n    // but do not appear in the debugger call frames\n    const frames = (exception.stacktrace?.frames || []).filter(frame => frame.function !== 'new Promise');\n\n    for (let i = 0; i < frames.length; i++) {\n      // Sentry frames are in reverse order\n      const frameIndex = frames.length - i - 1;\n\n      // Drop out if we run out of frames to match up\n      if (!frames[frameIndex] || !cachedFrame[i]) {\n        break;\n      }\n\n      if (\n        // We need to have vars to add\n        cachedFrame[i].vars === undefined ||\n        // We're not interested in frames that are not in_app because the vars are not relevant\n        frames[frameIndex].in_app === false ||\n        // The function names need to match\n        !functionNamesMatch(frames[frameIndex].function, cachedFrame[i].function)\n      ) {\n        continue;\n      }\n\n      frames[frameIndex].vars = cachedFrame[i].vars;\n    }\n  }\n\n  function addLocalVariablesToEvent(event: Event): Event {\n    for (const exception of event?.exception?.values || []) {\n      addLocalVariablesToException(exception);\n    }\n\n    return event;\n  }\n\n  return {\n    name: INTEGRATION_NAME,\n    setupOnce() {\n      const client = getClient<NodeClient>();\n      const clientOptions = client?.getOptions();\n\n      if (session && clientOptions?.includeLocalVariables) {\n        // Only setup this integration if the Node version is >= v18\n        // https://github.com/getsentry/sentry-javascript/issues/7697\n        const unsupportedNodeVersion = NODE_VERSION.major < 18;\n\n        if (unsupportedNodeVersion) {\n          logger.log('The `LocalVariables` integration is only supported on Node >= v18.');\n          return;\n        }\n\n        const captureAll = options.captureAllExceptions !== false;\n\n        session.configureAndConnect(\n          (ev, complete) =>\n            handlePaused(clientOptions.stackParser, ev as InspectorNotification<PausedExceptionEvent>, complete),\n          captureAll,\n        );\n\n        if (captureAll) {\n          const max = options.maxExceptionsPerSecond || 50;\n\n          rateLimiter = createRateLimiter(\n            max,\n            () => {\n              logger.log('Local variables rate-limit lifted.');\n              session?.setPauseOnExceptions(true);\n            },\n            seconds => {\n              logger.log(\n                `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`,\n              );\n              session?.setPauseOnExceptions(false);\n            },\n          );\n        }\n\n        shouldProcessEvent = true;\n      }\n    },\n    processEvent(event: Event): Event {\n      if (shouldProcessEvent) {\n        return addLocalVariablesToEvent(event);\n      }\n\n      return event;\n    },\n    // These are entirely for testing\n    _getCachedFramesCount(): number {\n      return cachedFrames.size;\n    },\n    _getFirstCachedFrame(): FrameVariables[] | undefined {\n      return cachedFrames.values()[0];\n    },\n  };\n}) satisfies IntegrationFn;\n\nexport const localVariablesSyncIntegration = defineIntegration(_localVariablesSyncIntegration);\n\n/**\n * Adds local variables to exception frames.\n * @deprecated Use `localVariablesSyncIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const LocalVariablesSync = convertIntegrationFnToClass(\n  INTEGRATION_NAME,\n  localVariablesSyncIntegration,\n) as IntegrationClass<Integration & { processEvent: (event: Event) => Event; setup: (client: NodeClient) => void }> & {\n  new (options?: LocalVariablesIntegrationOptions, session?: DebugSession): Integration;\n};\n\n// eslint-disable-next-line deprecation/deprecation\nexport type LocalVariablesSync = typeof LocalVariablesSync;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}