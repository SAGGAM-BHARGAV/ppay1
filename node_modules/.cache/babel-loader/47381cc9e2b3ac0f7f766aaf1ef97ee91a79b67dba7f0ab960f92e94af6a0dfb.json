{"ast":null,"code":"import { logger } from '@sentry/utils';\nfunction debug(...args) {\n  logger.log('[https-proxy-agent:parse-proxy-response]', ...args);\n}\nfunction parseProxyResponse(socket) {\n  return new Promise((resolve, reject) => {\n    // we need to buffer any HTTP traffic that happens with the proxy before we get\n    // the CONNECT response, so that if the response is anything other than an \"200\"\n    // response code, then we can re-play the \"data\" events on the socket once the\n    // HTTP parser is hooked up...\n    let buffersLength = 0;\n    const buffers = [];\n    function read() {\n      const b = socket.read();\n      if (b) ondata(b);else socket.once('readable', read);\n    }\n    function cleanup() {\n      socket.removeListener('end', onend);\n      socket.removeListener('error', onerror);\n      socket.removeListener('readable', read);\n    }\n    function onend() {\n      cleanup();\n      debug('onend');\n      reject(new Error('Proxy connection ended before receiving CONNECT response'));\n    }\n    function onerror(err) {\n      cleanup();\n      debug('onerror %o', err);\n      reject(err);\n    }\n    function ondata(b) {\n      buffers.push(b);\n      buffersLength += b.length;\n      const buffered = Buffer.concat(buffers, buffersLength);\n      const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n      if (endOfHeaders === -1) {\n        // keep buffering\n        debug('have not received end of HTTP headers yet...');\n        read();\n        return;\n      }\n      const headerParts = buffered.slice(0, endOfHeaders).toString('ascii').split('\\r\\n');\n      const firstLine = headerParts.shift();\n      if (!firstLine) {\n        socket.destroy();\n        return reject(new Error('No header received from proxy CONNECT response'));\n      }\n      const firstLineParts = firstLine.split(' ');\n      const statusCode = +firstLineParts[1];\n      const statusText = firstLineParts.slice(2).join(' ');\n      const headers = {};\n      for (const header of headerParts) {\n        if (!header) continue;\n        const firstColon = header.indexOf(':');\n        if (firstColon === -1) {\n          socket.destroy();\n          return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\n        }\n        const key = header.slice(0, firstColon).toLowerCase();\n        const value = header.slice(firstColon + 1).trimStart();\n        const current = headers[key];\n        if (typeof current === 'string') {\n          headers[key] = [current, value];\n        } else if (Array.isArray(current)) {\n          current.push(value);\n        } else {\n          headers[key] = value;\n        }\n      }\n      debug('got proxy server response: %o %o', firstLine, headers);\n      cleanup();\n      resolve({\n        connect: {\n          statusCode,\n          statusText,\n          headers\n        },\n        buffered\n      });\n    }\n    socket.on('error', onerror);\n    socket.on('end', onend);\n    read();\n  });\n}\nexport { parseProxyResponse };","map":{"version":3,"names":["debug","args","logger","log","parseProxyResponse","socket","Promise","resolve","reject","buffersLength","buffers","read","b","ondata","once","cleanup","removeListener","onend","onerror","Error","err","push","length","buffered","Buffer","concat","endOfHeaders","indexOf","headerParts","slice","toString","split","firstLine","shift","destroy","firstLineParts","statusCode","statusText","join","headers","header","firstColon","key","toLowerCase","value","trimStart","current","Array","isArray","connect","on"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\proxy\\parse-proxy-response.ts"],"sourcesContent":["/**\n * This code was originally forked from https://github.com/TooTallNate/proxy-agents/tree/b133295fd16f6475578b6b15bd9b4e33ecb0d0b7\n * With the following licence:\n *\n * (The MIT License)\n *\n * Copyright (c) 2013 Nathan Rajlich <nathan@tootallnate.net>*\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:*\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.*\n *\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\n/* eslint-disable jsdoc/require-jsdoc */\nimport type { IncomingHttpHeaders } from 'http';\nimport type { Readable } from 'stream';\nimport { logger } from '@sentry/utils';\n\nfunction debug(...args: unknown[]): void {\n  logger.log('[https-proxy-agent:parse-proxy-response]', ...args);\n}\n\nexport interface ConnectResponse {\n  statusCode: number;\n  statusText: string;\n  headers: IncomingHttpHeaders;\n}\n\nexport function parseProxyResponse(socket: Readable): Promise<{ connect: ConnectResponse; buffered: Buffer }> {\n  return new Promise((resolve, reject) => {\n    // we need to buffer any HTTP traffic that happens with the proxy before we get\n    // the CONNECT response, so that if the response is anything other than an \"200\"\n    // response code, then we can re-play the \"data\" events on the socket once the\n    // HTTP parser is hooked up...\n    let buffersLength = 0;\n    const buffers: Buffer[] = [];\n\n    function read() {\n      const b = socket.read();\n      if (b) ondata(b);\n      else socket.once('readable', read);\n    }\n\n    function cleanup() {\n      socket.removeListener('end', onend);\n      socket.removeListener('error', onerror);\n      socket.removeListener('readable', read);\n    }\n\n    function onend() {\n      cleanup();\n      debug('onend');\n      reject(new Error('Proxy connection ended before receiving CONNECT response'));\n    }\n\n    function onerror(err: Error) {\n      cleanup();\n      debug('onerror %o', err);\n      reject(err);\n    }\n\n    function ondata(b: Buffer) {\n      buffers.push(b);\n      buffersLength += b.length;\n\n      const buffered = Buffer.concat(buffers, buffersLength);\n      const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n\n      if (endOfHeaders === -1) {\n        // keep buffering\n        debug('have not received end of HTTP headers yet...');\n        read();\n        return;\n      }\n\n      const headerParts = buffered.slice(0, endOfHeaders).toString('ascii').split('\\r\\n');\n      const firstLine = headerParts.shift();\n      if (!firstLine) {\n        socket.destroy();\n        return reject(new Error('No header received from proxy CONNECT response'));\n      }\n      const firstLineParts = firstLine.split(' ');\n      const statusCode = +firstLineParts[1];\n      const statusText = firstLineParts.slice(2).join(' ');\n      const headers: IncomingHttpHeaders = {};\n      for (const header of headerParts) {\n        if (!header) continue;\n        const firstColon = header.indexOf(':');\n        if (firstColon === -1) {\n          socket.destroy();\n          return reject(new Error(`Invalid header from proxy CONNECT response: \"${header}\"`));\n        }\n        const key = header.slice(0, firstColon).toLowerCase();\n        const value = header.slice(firstColon + 1).trimStart();\n        const current = headers[key];\n        if (typeof current === 'string') {\n          headers[key] = [current, value];\n        } else if (Array.isArray(current)) {\n          current.push(value);\n        } else {\n          headers[key] = value;\n        }\n      }\n      debug('got proxy server response: %o %o', firstLine, headers);\n      cleanup();\n      resolve({\n        connect: {\n          statusCode,\n          statusText,\n          headers,\n        },\n        buffered,\n      });\n    }\n\n    socket.on('error', onerror);\n    socket.on('end', onend);\n\n    read();\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}