{"ast":null,"code":"import { withMonitor } from '@sentry/core';\nimport { replaceCronNames } from './common.js';\nconst ERROR_TEXT = 'Automatic instrumentation of CronJob only supports crontab string';\n\n/**\n * Instruments the `cron` library to send a check-in event to Sentry for each job execution.\n *\n * ```ts\n * import * as Sentry from '@sentry/node';\n * import { CronJob } from 'cron';\n *\n * const CronJobWithCheckIn = Sentry.cron.instrumentCron(CronJob, 'my-cron-job');\n *\n * // use the constructor\n * const job = new CronJobWithCheckIn('* * * * *', () => {\n *  console.log('You will see this message every minute');\n * });\n *\n * // or from\n * const job = CronJobWithCheckIn.from({ cronTime: '* * * * *', onTick: () => {\n *   console.log('You will see this message every minute');\n * });\n * ```\n */\nfunction instrumentCron(lib, monitorSlug) {\n  let jobScheduled = false;\n  return new Proxy(lib, {\n    construct(target, args) {\n      const [cronTime, onTick, onComplete, start, timeZone, ...rest] = args;\n      if (typeof cronTime !== 'string') {\n        throw new Error(ERROR_TEXT);\n      }\n      if (jobScheduled) {\n        throw new Error(`A job named '${monitorSlug}' has already been scheduled`);\n      }\n      jobScheduled = true;\n      const cronString = replaceCronNames(cronTime);\n      function monitoredTick(context, onComplete) {\n        return withMonitor(monitorSlug, () => {\n          return onTick(context, onComplete);\n        }, {\n          schedule: {\n            type: 'crontab',\n            value: cronString\n          },\n          timezone: timeZone || undefined\n        });\n      }\n      return new target(cronTime, monitoredTick, onComplete, start, timeZone, ...rest);\n    },\n    get(target, prop) {\n      if (prop === 'from') {\n        return param => {\n          const {\n            cronTime,\n            onTick,\n            timeZone\n          } = param;\n          if (typeof cronTime !== 'string') {\n            throw new Error(ERROR_TEXT);\n          }\n          if (jobScheduled) {\n            throw new Error(`A job named '${monitorSlug}' has already been scheduled`);\n          }\n          jobScheduled = true;\n          const cronString = replaceCronNames(cronTime);\n          param.onTick = (context, onComplete) => {\n            return withMonitor(monitorSlug, () => {\n              return onTick(context, onComplete);\n            }, {\n              schedule: {\n                type: 'crontab',\n                value: cronString\n              },\n              timezone: timeZone || undefined\n            });\n          };\n          return target.from(param);\n        };\n      } else {\n        return target[prop];\n      }\n    }\n  });\n}\nexport { instrumentCron };","map":{"version":3,"names":["ERROR_TEXT","instrumentCron","lib","monitorSlug","jobScheduled","Proxy","construct","target","args","cronTime","onTick","onComplete","start","timeZone","rest","Error","cronString","replaceCronNames","monitoredTick","context","withMonitor","schedule","type","value","timezone","undefined","get","prop","param","from"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\cron\\cron.ts"],"sourcesContent":["import { withMonitor } from '@sentry/core';\nimport { replaceCronNames } from './common';\n\nexport type CronJobParams = {\n  cronTime: string | Date;\n  onTick: (context: unknown, onComplete?: unknown) => void | Promise<void>;\n  onComplete?: () => void | Promise<void>;\n  start?: boolean | null;\n  context?: unknown;\n  runOnInit?: boolean | null;\n  unrefTimeout?: boolean | null;\n} & (\n  | {\n      timeZone?: string | null;\n      utcOffset?: never;\n    }\n  | {\n      timeZone?: never;\n      utcOffset?: number | null;\n    }\n);\n\nexport type CronJob = {\n  //\n};\n\nexport type CronJobConstructor = {\n  from: (param: CronJobParams) => CronJob;\n\n  new (\n    cronTime: CronJobParams['cronTime'],\n    onTick: CronJobParams['onTick'],\n    onComplete?: CronJobParams['onComplete'],\n    start?: CronJobParams['start'],\n    timeZone?: CronJobParams['timeZone'],\n    context?: CronJobParams['context'],\n    runOnInit?: CronJobParams['runOnInit'],\n    utcOffset?: null,\n    unrefTimeout?: CronJobParams['unrefTimeout'],\n  ): CronJob;\n  new (\n    cronTime: CronJobParams['cronTime'],\n    onTick: CronJobParams['onTick'],\n    onComplete?: CronJobParams['onComplete'],\n    start?: CronJobParams['start'],\n    timeZone?: null,\n    context?: CronJobParams['context'],\n    runOnInit?: CronJobParams['runOnInit'],\n    utcOffset?: CronJobParams['utcOffset'],\n    unrefTimeout?: CronJobParams['unrefTimeout'],\n  ): CronJob;\n};\n\nconst ERROR_TEXT = 'Automatic instrumentation of CronJob only supports crontab string';\n\n/**\n * Instruments the `cron` library to send a check-in event to Sentry for each job execution.\n *\n * ```ts\n * import * as Sentry from '@sentry/node';\n * import { CronJob } from 'cron';\n *\n * const CronJobWithCheckIn = Sentry.cron.instrumentCron(CronJob, 'my-cron-job');\n *\n * // use the constructor\n * const job = new CronJobWithCheckIn('* * * * *', () => {\n *  console.log('You will see this message every minute');\n * });\n *\n * // or from\n * const job = CronJobWithCheckIn.from({ cronTime: '* * * * *', onTick: () => {\n *   console.log('You will see this message every minute');\n * });\n * ```\n */\nexport function instrumentCron<T>(lib: T & CronJobConstructor, monitorSlug: string): T {\n  let jobScheduled = false;\n\n  return new Proxy(lib, {\n    construct(target, args: ConstructorParameters<CronJobConstructor>) {\n      const [cronTime, onTick, onComplete, start, timeZone, ...rest] = args;\n\n      if (typeof cronTime !== 'string') {\n        throw new Error(ERROR_TEXT);\n      }\n\n      if (jobScheduled) {\n        throw new Error(`A job named '${monitorSlug}' has already been scheduled`);\n      }\n\n      jobScheduled = true;\n\n      const cronString = replaceCronNames(cronTime);\n\n      function monitoredTick(context: unknown, onComplete?: unknown): void | Promise<void> {\n        return withMonitor(\n          monitorSlug,\n          () => {\n            return onTick(context, onComplete);\n          },\n          {\n            schedule: { type: 'crontab', value: cronString },\n            timezone: timeZone || undefined,\n          },\n        );\n      }\n\n      return new target(cronTime, monitoredTick, onComplete, start, timeZone, ...rest);\n    },\n    get(target, prop: keyof CronJobConstructor) {\n      if (prop === 'from') {\n        return (param: CronJobParams) => {\n          const { cronTime, onTick, timeZone } = param;\n\n          if (typeof cronTime !== 'string') {\n            throw new Error(ERROR_TEXT);\n          }\n\n          if (jobScheduled) {\n            throw new Error(`A job named '${monitorSlug}' has already been scheduled`);\n          }\n\n          jobScheduled = true;\n\n          const cronString = replaceCronNames(cronTime);\n\n          param.onTick = (context: unknown, onComplete?: unknown) => {\n            return withMonitor(\n              monitorSlug,\n              () => {\n                return onTick(context, onComplete);\n              },\n              {\n                schedule: { type: 'crontab', value: cronString },\n                timezone: timeZone || undefined,\n              },\n            );\n          };\n\n          return target.from(param);\n        };\n      } else {\n        return target[prop];\n      }\n    },\n  });\n}\n"],"mappings":";;AAqDA,MAAMA,UAAA,GAAa,mEAAmE;;AAEtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,cAAcA,CAAIC,GAAG,EAA0BC,WAAW,EAAa;EACrF,IAAIC,YAAa,GAAE,KAAK;EAExB,OAAO,IAAIC,KAAK,CAACH,GAAG,EAAE;IACpBI,SAASA,CAACC,MAAM,EAAEC,IAAI,EAA6C;MACjE,MAAM,CAACC,QAAQ,EAAEC,MAAM,EAAEC,UAAU,EAAEC,KAAK,EAAEC,QAAQ,EAAE,GAAGC,IAAI,IAAIN,IAAI;MAErE,IAAI,OAAOC,QAAS,KAAI,QAAQ,EAAE;QAChC,MAAM,IAAIM,KAAK,CAACf,UAAU,CAAC;MACnC;MAEM,IAAII,YAAY,EAAE;QAChB,MAAM,IAAIW,KAAK,CAAE,gBAAeZ,WAAY,8BAA6B,CAAC;MAClF;MAEMC,YAAA,GAAe,IAAI;MAEnB,MAAMY,UAAW,GAAEC,gBAAgB,CAACR,QAAQ,CAAC;MAE7C,SAASS,aAAaA,CAACC,OAAO,EAAWR,UAAU,EAAkC;QACnF,OAAOS,WAAW,CAChBjB,WAAW,EACX,MAAM;UACJ,OAAOO,MAAM,CAACS,OAAO,EAAER,UAAU,CAAC;QAC9C,CAAW,EACD;UACEU,QAAQ,EAAE;YAAEC,IAAI,EAAE,SAAS;YAAEC,KAAK,EAAEP;UAAA,CAAY;UAChDQ,QAAQ,EAAEX,QAAS,IAAGY;QAClC,CACA,CAAS;MACT;MAEM,OAAO,IAAIlB,MAAM,CAACE,QAAQ,EAAES,aAAa,EAAEP,UAAU,EAAEC,KAAK,EAAEC,QAAQ,EAAE,GAAGC,IAAI,CAAC;IACtF,CAAK;IACDY,GAAGA,CAACnB,MAAM,EAAEoB,IAAI,EAA4B;MAC1C,IAAIA,IAAK,KAAI,MAAM,EAAE;QACnB,OAAQC,KAAK,IAAoB;UAC/B,MAAM;YAAEnB,QAAQ;YAAEC,MAAM;YAAEG;UAAA,CAAW,GAAEe,KAAK;UAE5C,IAAI,OAAOnB,QAAS,KAAI,QAAQ,EAAE;YAChC,MAAM,IAAIM,KAAK,CAACf,UAAU,CAAC;UACvC;UAEU,IAAII,YAAY,EAAE;YAChB,MAAM,IAAIW,KAAK,CAAE,gBAAeZ,WAAY,8BAA6B,CAAC;UACtF;UAEUC,YAAA,GAAe,IAAI;UAEnB,MAAMY,UAAW,GAAEC,gBAAgB,CAACR,QAAQ,CAAC;UAE7CmB,KAAK,CAAClB,MAAO,GAAE,CAACS,OAAO,EAAWR,UAAU,KAAe;YACzD,OAAOS,WAAW,CAChBjB,WAAW,EACX,MAAM;cACJ,OAAOO,MAAM,CAACS,OAAO,EAAER,UAAU,CAAC;YAClD,CAAe,EACD;cACEU,QAAQ,EAAE;gBAAEC,IAAI,EAAE,SAAS;gBAAEC,KAAK,EAAEP;cAAA,CAAY;cAChDQ,QAAQ,EAAEX,QAAS,IAAGY;YACtC,CACA,CAAa;UACb,CAAW;UAED,OAAOlB,MAAM,CAACsB,IAAI,CAACD,KAAK,CAAC;QACnC,CAAS;MACT,OAAa;QACL,OAAOrB,MAAM,CAACoB,IAAI,CAAC;MAC3B;IACA;EACA,CAAG,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}