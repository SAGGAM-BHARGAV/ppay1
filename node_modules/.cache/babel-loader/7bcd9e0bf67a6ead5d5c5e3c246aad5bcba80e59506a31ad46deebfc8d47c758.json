{"ast":null,"code":"import { _nullishCoalesce, _optionalChain } from '@sentry/utils';\nimport * as net from 'net';\nimport * as tls from 'tls';\nimport { URL } from 'url';\nimport { logger } from '@sentry/utils';\nimport { Agent } from './base.js';\nimport { parseProxyResponse } from './parse-proxy-response.js';\nfunction debug(...args) {\n  logger.log('[https-proxy-agent]', ...args);\n}\n\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n */\nclass HttpsProxyAgent extends Agent {\n  static __initStatic() {\n    this.protocols = ['http', 'https'];\n  }\n  constructor(proxy, opts) {\n    super(opts);\n    this.options = {};\n    this.proxy = typeof proxy === 'string' ? new URL(proxy) : proxy;\n    this.proxyHeaders = _nullishCoalesce(_optionalChain([opts, 'optionalAccess', _2 => _2.headers]), () => ({}));\n    debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);\n\n    // Trim off the brackets from IPv6 addresses\n    const host = (this.proxy.hostname || this.proxy.host).replace(/^\\[|\\]$/g, '');\n    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === 'https:' ? 443 : 80;\n    this.connectOpts = {\n      // Attempt to negotiate http/1.1 for proxy servers that support http/2\n      ALPNProtocols: ['http/1.1'],\n      ...(opts ? omit(opts, 'headers') : null),\n      host,\n      port\n    };\n  }\n\n  /**\n   * Called when the node-core HTTP client library is creating a\n   * new HTTP request.\n   */\n  async connect(req, opts) {\n    const {\n      proxy\n    } = this;\n    if (!opts.host) {\n      throw new TypeError('No \"host\" provided');\n    }\n\n    // Create a socket connection to the proxy server.\n    let socket;\n    if (proxy.protocol === 'https:') {\n      debug('Creating `tls.Socket`: %o', this.connectOpts);\n      const servername = this.connectOpts.servername || this.connectOpts.host;\n      socket = tls.connect({\n        ...this.connectOpts,\n        servername: servername && net.isIP(servername) ? undefined : servername\n      });\n    } else {\n      debug('Creating `net.Socket`: %o', this.connectOpts);\n      socket = net.connect(this.connectOpts);\n    }\n    const headers = typeof this.proxyHeaders === 'function' ? this.proxyHeaders() : {\n      ...this.proxyHeaders\n    };\n    const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;\n    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\\r\\n`;\n\n    // Inject the `Proxy-Authorization` header if necessary.\n    if (proxy.username || proxy.password) {\n      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;\n      headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;\n    }\n    headers.Host = `${host}:${opts.port}`;\n    if (!headers['Proxy-Connection']) {\n      headers['Proxy-Connection'] = this.keepAlive ? 'Keep-Alive' : 'close';\n    }\n    for (const name of Object.keys(headers)) {\n      payload += `${name}: ${headers[name]}\\r\\n`;\n    }\n    const proxyResponsePromise = parseProxyResponse(socket);\n    socket.write(`${payload}\\r\\n`);\n    const {\n      connect,\n      buffered\n    } = await proxyResponsePromise;\n    req.emit('proxyConnect', connect);\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not EventEmitter in Node types\n    this.emit('proxyConnect', connect, req);\n    if (connect.statusCode === 200) {\n      req.once('socket', resume);\n      if (opts.secureEndpoint) {\n        // The proxy is connecting to a TLS server, so upgrade\n        // this socket connection to a TLS connection.\n        debug('Upgrading socket connection to TLS');\n        const servername = opts.servername || opts.host;\n        return tls.connect({\n          ...omit(opts, 'host', 'path', 'port'),\n          socket,\n          servername: net.isIP(servername) ? undefined : servername\n        });\n      }\n      return socket;\n    }\n\n    // Some other status code that's not 200... need to re-play the HTTP\n    // header \"data\" events onto the socket once the HTTP machinery is\n    // attached so that the node core `http` can parse and handle the\n    // error status code.\n\n    // Close the original socket, and a new \"fake\" socket is returned\n    // instead, so that the proxy doesn't get the HTTP request\n    // written to it (which may contain `Authorization` headers or other\n    // sensitive data).\n    //\n    // See: https://hackerone.com/reports/541502\n    socket.destroy();\n    const fakeSocket = new net.Socket({\n      writable: false\n    });\n    fakeSocket.readable = true;\n\n    // Need to wait for the \"socket\" event to re-play the \"data\" events.\n    req.once('socket', s => {\n      debug('Replaying proxy buffer for failed request');\n      // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n      // this point the HTTP module machinery has been hooked up for\n      // the user.\n      s.push(buffered);\n      s.push(null);\n    });\n    return fakeSocket;\n  }\n}\nHttpsProxyAgent.__initStatic();\nfunction resume(socket) {\n  socket.resume();\n}\nfunction omit(obj, ...keys) {\n  const ret = {};\n  let key;\n  for (key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n  return ret;\n}\nexport { HttpsProxyAgent };","map":{"version":3,"names":["debug","args","logger","log","HttpsProxyAgent","Agent","__initStatic","protocols","constructor","proxy","opts","options","URL","proxyHeaders","_nullishCoalesce","_optionalChain","_2","headers","href","host","hostname","replace","port","parseInt","protocol","connectOpts","ALPNProtocols","omit","connect","req","TypeError","socket","servername","tls","net","isIP","undefined","isIPv6","payload","username","password","auth","decodeURIComponent","Buffer","from","toString","Host","keepAlive","name","Object","keys","proxyResponsePromise","parseProxyResponse","write","buffered","emit","statusCode","once","resume","secureEndpoint","destroy","fakeSocket","Socket","writable","readable","s","push","obj","ret","key","includes"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\proxy\\index.ts"],"sourcesContent":["/**\n * This code was originally forked from https://github.com/TooTallNate/proxy-agents/tree/b133295fd16f6475578b6b15bd9b4e33ecb0d0b7\n * With the following licence:\n *\n * (The MIT License)\n *\n * Copyright (c) 2013 Nathan Rajlich <nathan@tootallnate.net>*\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * 'Software'), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:*\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.*\n *\n * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* eslint-disable @typescript-eslint/explicit-member-accessibility */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport type * as http from 'http';\nimport type { OutgoingHttpHeaders } from 'http';\nimport * as net from 'net';\nimport * as tls from 'tls';\n// TODO (v8): Remove this when Node < 12 is no longer supported\nimport { URL } from 'url';\nimport { logger } from '@sentry/utils';\nimport { Agent } from './base';\nimport type { AgentConnectOpts } from './base';\nimport { parseProxyResponse } from './parse-proxy-response';\n\nfunction debug(...args: unknown[]): void {\n  logger.log('[https-proxy-agent]', ...args);\n}\n\ntype Protocol<T> = T extends `${infer Protocol}:${infer _}` ? Protocol : never;\n\ntype ConnectOptsMap = {\n  http: Omit<net.TcpNetConnectOpts, 'host' | 'port'>;\n  https: Omit<tls.ConnectionOptions, 'host' | 'port'>;\n};\n\ntype ConnectOpts<T> = {\n  [P in keyof ConnectOptsMap]: Protocol<T> extends P ? ConnectOptsMap[P] : never;\n}[keyof ConnectOptsMap];\n\nexport type HttpsProxyAgentOptions<T> = ConnectOpts<T> &\n  http.AgentOptions & {\n    headers?: OutgoingHttpHeaders | (() => OutgoingHttpHeaders);\n  };\n\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n */\nexport class HttpsProxyAgent<Uri extends string> extends Agent {\n  static protocols = ['http', 'https'] as const;\n\n  readonly proxy: URL;\n  proxyHeaders: OutgoingHttpHeaders | (() => OutgoingHttpHeaders);\n  connectOpts: net.TcpNetConnectOpts & tls.ConnectionOptions;\n\n  constructor(proxy: Uri | URL, opts?: HttpsProxyAgentOptions<Uri>) {\n    super(opts);\n    this.options = {};\n    this.proxy = typeof proxy === 'string' ? new URL(proxy) : proxy;\n    this.proxyHeaders = opts?.headers ?? {};\n    debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);\n\n    // Trim off the brackets from IPv6 addresses\n    const host = (this.proxy.hostname || this.proxy.host).replace(/^\\[|\\]$/g, '');\n    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === 'https:' ? 443 : 80;\n    this.connectOpts = {\n      // Attempt to negotiate http/1.1 for proxy servers that support http/2\n      ALPNProtocols: ['http/1.1'],\n      ...(opts ? omit(opts, 'headers') : null),\n      host,\n      port,\n    };\n  }\n\n  /**\n   * Called when the node-core HTTP client library is creating a\n   * new HTTP request.\n   */\n  async connect(req: http.ClientRequest, opts: AgentConnectOpts): Promise<net.Socket> {\n    const { proxy } = this;\n\n    if (!opts.host) {\n      throw new TypeError('No \"host\" provided');\n    }\n\n    // Create a socket connection to the proxy server.\n    let socket: net.Socket;\n    if (proxy.protocol === 'https:') {\n      debug('Creating `tls.Socket`: %o', this.connectOpts);\n      const servername = this.connectOpts.servername || this.connectOpts.host;\n      socket = tls.connect({\n        ...this.connectOpts,\n        servername: servername && net.isIP(servername) ? undefined : servername,\n      });\n    } else {\n      debug('Creating `net.Socket`: %o', this.connectOpts);\n      socket = net.connect(this.connectOpts);\n    }\n\n    const headers: OutgoingHttpHeaders =\n      typeof this.proxyHeaders === 'function' ? this.proxyHeaders() : { ...this.proxyHeaders };\n    const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;\n    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\\r\\n`;\n\n    // Inject the `Proxy-Authorization` header if necessary.\n    if (proxy.username || proxy.password) {\n      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;\n      headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;\n    }\n\n    headers.Host = `${host}:${opts.port}`;\n\n    if (!headers['Proxy-Connection']) {\n      headers['Proxy-Connection'] = this.keepAlive ? 'Keep-Alive' : 'close';\n    }\n    for (const name of Object.keys(headers)) {\n      payload += `${name}: ${headers[name]}\\r\\n`;\n    }\n\n    const proxyResponsePromise = parseProxyResponse(socket);\n\n    socket.write(`${payload}\\r\\n`);\n\n    const { connect, buffered } = await proxyResponsePromise;\n    req.emit('proxyConnect', connect);\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore Not EventEmitter in Node types\n    this.emit('proxyConnect', connect, req);\n\n    if (connect.statusCode === 200) {\n      req.once('socket', resume);\n\n      if (opts.secureEndpoint) {\n        // The proxy is connecting to a TLS server, so upgrade\n        // this socket connection to a TLS connection.\n        debug('Upgrading socket connection to TLS');\n        const servername = opts.servername || opts.host;\n        return tls.connect({\n          ...omit(opts, 'host', 'path', 'port'),\n          socket,\n          servername: net.isIP(servername) ? undefined : servername,\n        });\n      }\n\n      return socket;\n    }\n\n    // Some other status code that's not 200... need to re-play the HTTP\n    // header \"data\" events onto the socket once the HTTP machinery is\n    // attached so that the node core `http` can parse and handle the\n    // error status code.\n\n    // Close the original socket, and a new \"fake\" socket is returned\n    // instead, so that the proxy doesn't get the HTTP request\n    // written to it (which may contain `Authorization` headers or other\n    // sensitive data).\n    //\n    // See: https://hackerone.com/reports/541502\n    socket.destroy();\n\n    const fakeSocket = new net.Socket({ writable: false });\n    fakeSocket.readable = true;\n\n    // Need to wait for the \"socket\" event to re-play the \"data\" events.\n    req.once('socket', (s: net.Socket) => {\n      debug('Replaying proxy buffer for failed request');\n      // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n      // this point the HTTP module machinery has been hooked up for\n      // the user.\n      s.push(buffered);\n      s.push(null);\n    });\n\n    return fakeSocket;\n  }\n}\n\nfunction resume(socket: net.Socket | tls.TLSSocket): void {\n  socket.resume();\n}\n\nfunction omit<T extends object, K extends [...(keyof T)[]]>(\n  obj: T,\n  ...keys: K\n): {\n  [K2 in Exclude<keyof T, K[number]>]: T[K2];\n} {\n  const ret = {} as {\n    [K in keyof typeof obj]: (typeof obj)[K];\n  };\n  let key: keyof typeof obj;\n  for (key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n  return ret;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}