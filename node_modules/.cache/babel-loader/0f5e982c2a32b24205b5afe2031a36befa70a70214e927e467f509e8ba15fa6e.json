{"ast":null,"code":"import { _optionalChain } from '@sentry/utils';\nimport { hasTracingEnabled, continueTrace, startTransaction, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, getCurrentScope, setHttpStatus, getClient, flush, runWithAsyncContext, withScope, getActiveSpan, captureException } from '@sentry/core';\nimport { isString, extractPathForTransaction, extractRequestData, addRequestDataToTransaction, logger, dropUndefinedKeys } from '@sentry/utils';\nimport { DEBUG_BUILD } from './debug-build.js';\nimport { isAutoSessionTrackingEnabled } from './sdk.js';\nimport { trpcMiddleware as trpcMiddleware$1 } from './trpc.js';\nexport { extractRequestData, parseRequest } from './requestDataDeprecated.js';\n\n/**\n * Express-compatible tracing handler.\n * @see Exposed as `Handlers.tracingHandler`\n */\nfunction tracingHandler() {\n  return function sentryTracingMiddleware(req, res, next) {\n    const options = _optionalChain([getClient, 'call', _ => _(), 'optionalAccess', _2 => _2.getOptions, 'call', _3 => _3()]);\n    if (!options || options.instrumenter !== 'sentry' || _optionalChain([req, 'access', _4 => _4.method, 'optionalAccess', _5 => _5.toUpperCase, 'call', _6 => _6()]) === 'OPTIONS' || _optionalChain([req, 'access', _7 => _7.method, 'optionalAccess', _8 => _8.toUpperCase, 'call', _9 => _9()]) === 'HEAD') {\n      return next();\n    }\n    const sentryTrace = req.headers && isString(req.headers['sentry-trace']) ? req.headers['sentry-trace'] : undefined;\n    const baggage = _optionalChain([req, 'access', _10 => _10.headers, 'optionalAccess', _11 => _11.baggage]);\n    if (!hasTracingEnabled(options)) {\n      return next();\n    }\n    const [name, source] = extractPathForTransaction(req, {\n      path: true,\n      method: true\n    });\n    const transaction = continueTrace({\n      sentryTrace,\n      baggage\n    }, ctx =>\n    // TODO: Refactor this to use `startSpan()`\n    // eslint-disable-next-line deprecation/deprecation\n    startTransaction({\n      name,\n      op: 'http.server',\n      origin: 'auto.http.node.tracingHandler',\n      ...ctx,\n      data: {\n        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source\n      },\n      metadata: {\n        // eslint-disable-next-line deprecation/deprecation\n        ...ctx.metadata,\n        // The request should already have been stored in `scope.sdkProcessingMetadata` (which will become\n        // `event.sdkProcessingMetadata` the same way the metadata here will) by `sentryRequestMiddleware`, but on the\n        // off chance someone is using `sentryTracingMiddleware` without `sentryRequestMiddleware`, it doesn't hurt to\n        // be sure\n        request: req\n      }\n    },\n    // extra context passed to the tracesSampler\n    {\n      request: extractRequestData(req)\n    }));\n\n    // We put the transaction on the scope so users can attach children to it\n    // eslint-disable-next-line deprecation/deprecation\n    getCurrentScope().setSpan(transaction);\n\n    // We also set __sentry_transaction on the response so people can grab the transaction there to add\n    // spans to it later.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    res.__sentry_transaction = transaction;\n    res.once('finish', () => {\n      // Push `transaction.finish` to the next event loop so open spans have a chance to finish before the transaction\n      // closes\n      setImmediate(() => {\n        // eslint-disable-next-line deprecation/deprecation\n        addRequestDataToTransaction(transaction, req);\n        setHttpStatus(transaction, res.statusCode);\n        transaction.end();\n      });\n    });\n    next();\n  };\n}\n\n/**\n * Backwards compatibility shim which can be removed in v8. Forces the given options to follow the\n * `AddRequestDataToEventOptions` interface.\n *\n * TODO (v8): Get rid of this, and stop passing `requestDataOptionsFromExpressHandler` to `setSDKProcessingMetadata`.\n */\nfunction convertReqHandlerOptsToAddReqDataOpts(reqHandlerOptions = {}) {\n  let addRequestDataOptions;\n  if ('include' in reqHandlerOptions) {\n    addRequestDataOptions = {\n      include: reqHandlerOptions.include\n    };\n  } else {\n    // eslint-disable-next-line deprecation/deprecation\n    const {\n      ip,\n      request,\n      transaction,\n      user\n    } = reqHandlerOptions;\n    if (ip || request || transaction || user) {\n      addRequestDataOptions = {\n        include: dropUndefinedKeys({\n          ip,\n          request,\n          transaction,\n          user\n        })\n      };\n    }\n  }\n  return addRequestDataOptions;\n}\n\n/**\n * Express compatible request handler.\n * @see Exposed as `Handlers.requestHandler`\n */\nfunction requestHandler(options) {\n  // TODO (v8): Get rid of this\n  const requestDataOptions = convertReqHandlerOptsToAddReqDataOpts(options);\n  const client = getClient();\n  // Initialise an instance of SessionFlusher on the client when `autoSessionTracking` is enabled and the\n  // `requestHandler` middleware is used indicating that we are running in SessionAggregates mode\n  if (client && isAutoSessionTrackingEnabled(client)) {\n    client.initSessionFlusher();\n\n    // If Scope contains a Single mode Session, it is removed in favor of using Session Aggregates mode\n    const scope = getCurrentScope();\n    if (scope.getSession()) {\n      scope.setSession();\n    }\n  }\n  return function sentryRequestMiddleware(req, res, next) {\n    if (options && options.flushTimeout && options.flushTimeout > 0) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _end = res.end;\n      res.end = function (chunk, encoding, cb) {\n        void flush(options.flushTimeout).then(() => {\n          _end.call(this, chunk, encoding, cb);\n        }).then(null, e => {\n          DEBUG_BUILD && logger.error(e);\n          _end.call(this, chunk, encoding, cb);\n        });\n      };\n    }\n    runWithAsyncContext(() => {\n      const scope = getCurrentScope();\n      scope.setSDKProcessingMetadata({\n        request: req,\n        // TODO (v8): Stop passing this\n        requestDataOptionsFromExpressHandler: requestDataOptions\n      });\n      const client = getClient();\n      if (isAutoSessionTrackingEnabled(client)) {\n        // Set `status` of `RequestSession` to Ok, at the beginning of the request\n        scope.setRequestSession({\n          status: 'ok'\n        });\n      }\n      res.once('finish', () => {\n        const client = getClient();\n        if (isAutoSessionTrackingEnabled(client)) {\n          setImmediate(() => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (client && client._captureRequestSession) {\n              // Calling _captureRequestSession to capture request session at the end of the request by incrementing\n              // the correct SessionAggregates bucket i.e. crashed, errored or exited\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n              client._captureRequestSession();\n            }\n          });\n        }\n      });\n      next();\n    });\n  };\n}\n\n/** JSDoc */\n\n/** JSDoc */\nfunction getStatusCodeFromResponse(error) {\n  const statusCode = error.status || error.statusCode || error.status_code || error.output && error.output.statusCode;\n  return statusCode ? parseInt(statusCode, 10) : 500;\n}\n\n/** Returns true if response code is internal server error */\nfunction defaultShouldHandleError(error) {\n  const status = getStatusCodeFromResponse(error);\n  return status >= 500;\n}\n\n/**\n * Express compatible error handler.\n * @see Exposed as `Handlers.errorHandler`\n */\nfunction errorHandler(options) {\n  return function sentryErrorMiddleware(error, _req, res, next) {\n    const shouldHandleError = options && options.shouldHandleError || defaultShouldHandleError;\n    if (shouldHandleError(error)) {\n      withScope(_scope => {\n        // The request should already have been stored in `scope.sdkProcessingMetadata` by `sentryRequestMiddleware`,\n        // but on the off chance someone is using `sentryErrorMiddleware` without `sentryRequestMiddleware`, it doesn't\n        // hurt to be sure\n        _scope.setSDKProcessingMetadata({\n          request: _req\n        });\n\n        // For some reason we need to set the transaction on the scope again\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        const transaction = res.__sentry_transaction;\n        if (transaction && !getActiveSpan()) {\n          // eslint-disable-next-line deprecation/deprecation\n          _scope.setSpan(transaction);\n        }\n        const client = getClient();\n        if (client && isAutoSessionTrackingEnabled(client)) {\n          // Check if the `SessionFlusher` is instantiated on the client to go into this branch that marks the\n          // `requestSession.status` as `Crashed`, and this check is necessary because the `SessionFlusher` is only\n          // instantiated when the the`requestHandler` middleware is initialised, which indicates that we should be\n          // running in SessionAggregates mode\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          const isSessionAggregatesMode = client._sessionFlusher !== undefined;\n          if (isSessionAggregatesMode) {\n            const requestSession = _scope.getRequestSession();\n            // If an error bubbles to the `errorHandler`, then this is an unhandled error, and should be reported as a\n            // Crashed session. The `_requestSession.status` is checked to ensure that this error is happening within\n            // the bounds of a request, and if so the status is updated\n            if (requestSession && requestSession.status !== undefined) {\n              requestSession.status = 'crashed';\n            }\n          }\n        }\n        const eventId = captureException(error, {\n          mechanism: {\n            type: 'middleware',\n            handled: false\n          }\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        res.sentry = eventId;\n        next(error);\n      });\n      return;\n    }\n    next(error);\n  };\n}\n\n/**\n * Sentry tRPC middleware that names the handling transaction after the called procedure.\n *\n * Use the Sentry tRPC middleware in combination with the Sentry server integration,\n * e.g. Express Request Handlers or Next.js SDK.\n *\n * @deprecated Please use the top level export instead:\n * ```\n * // OLD\n * import * as Sentry from '@sentry/node';\n * Sentry.Handlers.trpcMiddleware();\n *\n * // NEW\n * import * as Sentry from '@sentry/node';\n * Sentry.trpcMiddleware();\n * ```\n */\n// eslint-disable-next-line deprecation/deprecation\nconst trpcMiddleware = trpcMiddleware$1;\nexport { errorHandler, requestHandler, tracingHandler, trpcMiddleware };","map":{"version":3,"names":["tracingHandler","sentryTracingMiddleware","req","res","next","options","_optionalChain","getClient","_","_2","getOptions","_3","instrumenter","_4","method","_5","toUpperCase","_6","_7","_8","_9","sentryTrace","headers","isString","undefined","baggage","_10","_11","hasTracingEnabled","name","source","extractPathForTransaction","path","transaction","continueTrace","ctx","startTransaction","op","origin","data","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","metadata","request","extractRequestData","getCurrentScope","setSpan","__sentry_transaction","once","setImmediate","addRequestDataToTransaction","setHttpStatus","statusCode","end","convertReqHandlerOptsToAddReqDataOpts","reqHandlerOptions","addRequestDataOptions","include","ip","user","dropUndefinedKeys","requestHandler","requestDataOptions","client","isAutoSessionTrackingEnabled","initSessionFlusher","scope","getSession","setSession","sentryRequestMiddleware","flushTimeout","_end","chunk","encoding","cb","flush","then","call","e","DEBUG_BUILD","logger","error","runWithAsyncContext","setSDKProcessingMetadata","requestDataOptionsFromExpressHandler","setRequestSession","status","_captureRequestSession","getStatusCodeFromResponse","status_code","output","parseInt","defaultShouldHandleError","errorHandler","sentryErrorMiddleware","_req","shouldHandleError","withScope","_scope","getActiveSpan","isSessionAggregatesMode","_sessionFlusher","requestSession","getRequestSession","eventId","captureException","mechanism","type","handled","sentry","trpcMiddleware","trpcMiddleware$1"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\handlers.ts"],"sourcesContent":["import type * as http from 'http';\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  captureException,\n  continueTrace,\n  flush,\n  getActiveSpan,\n  getClient,\n  getCurrentScope,\n  hasTracingEnabled,\n  runWithAsyncContext,\n  setHttpStatus,\n  startTransaction,\n  withScope,\n} from '@sentry/core';\nimport type { Span } from '@sentry/types';\nimport type { AddRequestDataToEventOptions } from '@sentry/utils';\nimport {\n  addRequestDataToTransaction,\n  dropUndefinedKeys,\n  extractPathForTransaction,\n  extractRequestData,\n  isString,\n  logger,\n} from '@sentry/utils';\n\nimport type { NodeClient } from './client';\nimport { DEBUG_BUILD } from './debug-build';\n// TODO (v8 / XXX) Remove this import\nimport type { ParseRequestOptions } from './requestDataDeprecated';\nimport { isAutoSessionTrackingEnabled } from './sdk';\nimport { trpcMiddleware as newTrpcMiddleware } from './trpc';\n\n/**\n * Express-compatible tracing handler.\n * @see Exposed as `Handlers.tracingHandler`\n */\nexport function tracingHandler(): (\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: (error?: any) => void,\n) => void {\n  return function sentryTracingMiddleware(\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error?: any) => void,\n  ): void {\n    const options = getClient()?.getOptions();\n\n    if (\n      !options ||\n      options.instrumenter !== 'sentry' ||\n      req.method?.toUpperCase() === 'OPTIONS' ||\n      req.method?.toUpperCase() === 'HEAD'\n    ) {\n      return next();\n    }\n\n    const sentryTrace = req.headers && isString(req.headers['sentry-trace']) ? req.headers['sentry-trace'] : undefined;\n    const baggage = req.headers?.baggage;\n    if (!hasTracingEnabled(options)) {\n      return next();\n    }\n\n    const [name, source] = extractPathForTransaction(req, { path: true, method: true });\n    const transaction = continueTrace({ sentryTrace, baggage }, ctx =>\n      // TODO: Refactor this to use `startSpan()`\n      // eslint-disable-next-line deprecation/deprecation\n      startTransaction(\n        {\n          name,\n          op: 'http.server',\n          origin: 'auto.http.node.tracingHandler',\n          ...ctx,\n          data: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n          },\n          metadata: {\n            // eslint-disable-next-line deprecation/deprecation\n            ...ctx.metadata,\n            // The request should already have been stored in `scope.sdkProcessingMetadata` (which will become\n            // `event.sdkProcessingMetadata` the same way the metadata here will) by `sentryRequestMiddleware`, but on the\n            // off chance someone is using `sentryTracingMiddleware` without `sentryRequestMiddleware`, it doesn't hurt to\n            // be sure\n            request: req,\n          },\n        },\n        // extra context passed to the tracesSampler\n        { request: extractRequestData(req) },\n      ),\n    );\n\n    // We put the transaction on the scope so users can attach children to it\n    // eslint-disable-next-line deprecation/deprecation\n    getCurrentScope().setSpan(transaction);\n\n    // We also set __sentry_transaction on the response so people can grab the transaction there to add\n    // spans to it later.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    (res as any).__sentry_transaction = transaction;\n\n    res.once('finish', () => {\n      // Push `transaction.finish` to the next event loop so open spans have a chance to finish before the transaction\n      // closes\n      setImmediate(() => {\n        // eslint-disable-next-line deprecation/deprecation\n        addRequestDataToTransaction(transaction, req);\n        setHttpStatus(transaction, res.statusCode);\n        transaction.end();\n      });\n    });\n\n    next();\n  };\n}\n\nexport type RequestHandlerOptions =\n  // TODO (v8 / XXX) Remove ParseRequestOptions type and eslint override\n  // eslint-disable-next-line deprecation/deprecation\n  (ParseRequestOptions | AddRequestDataToEventOptions) & {\n    flushTimeout?: number;\n  };\n\n/**\n * Backwards compatibility shim which can be removed in v8. Forces the given options to follow the\n * `AddRequestDataToEventOptions` interface.\n *\n * TODO (v8): Get rid of this, and stop passing `requestDataOptionsFromExpressHandler` to `setSDKProcessingMetadata`.\n */\nfunction convertReqHandlerOptsToAddReqDataOpts(\n  reqHandlerOptions: RequestHandlerOptions = {},\n): AddRequestDataToEventOptions | undefined {\n  let addRequestDataOptions: AddRequestDataToEventOptions | undefined;\n\n  if ('include' in reqHandlerOptions) {\n    addRequestDataOptions = { include: reqHandlerOptions.include };\n  } else {\n    // eslint-disable-next-line deprecation/deprecation\n    const { ip, request, transaction, user } = reqHandlerOptions as ParseRequestOptions;\n\n    if (ip || request || transaction || user) {\n      addRequestDataOptions = { include: dropUndefinedKeys({ ip, request, transaction, user }) };\n    }\n  }\n\n  return addRequestDataOptions;\n}\n\n/**\n * Express compatible request handler.\n * @see Exposed as `Handlers.requestHandler`\n */\nexport function requestHandler(\n  options?: RequestHandlerOptions,\n): (req: http.IncomingMessage, res: http.ServerResponse, next: (error?: any) => void) => void {\n  // TODO (v8): Get rid of this\n  const requestDataOptions = convertReqHandlerOptsToAddReqDataOpts(options);\n\n  const client = getClient<NodeClient>();\n  // Initialise an instance of SessionFlusher on the client when `autoSessionTracking` is enabled and the\n  // `requestHandler` middleware is used indicating that we are running in SessionAggregates mode\n  if (client && isAutoSessionTrackingEnabled(client)) {\n    client.initSessionFlusher();\n\n    // If Scope contains a Single mode Session, it is removed in favor of using Session Aggregates mode\n    const scope = getCurrentScope();\n    if (scope.getSession()) {\n      scope.setSession();\n    }\n  }\n\n  return function sentryRequestMiddleware(\n    req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error?: any) => void,\n  ): void {\n    if (options && options.flushTimeout && options.flushTimeout > 0) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _end = res.end;\n      res.end = function (chunk?: any | (() => void), encoding?: string | (() => void), cb?: () => void): void {\n        void flush(options.flushTimeout)\n          .then(() => {\n            _end.call(this, chunk, encoding, cb);\n          })\n          .then(null, e => {\n            DEBUG_BUILD && logger.error(e);\n            _end.call(this, chunk, encoding, cb);\n          });\n      };\n    }\n    runWithAsyncContext(() => {\n      const scope = getCurrentScope();\n      scope.setSDKProcessingMetadata({\n        request: req,\n        // TODO (v8): Stop passing this\n        requestDataOptionsFromExpressHandler: requestDataOptions,\n      });\n\n      const client = getClient<NodeClient>();\n      if (isAutoSessionTrackingEnabled(client)) {\n        // Set `status` of `RequestSession` to Ok, at the beginning of the request\n        scope.setRequestSession({ status: 'ok' });\n      }\n\n      res.once('finish', () => {\n        const client = getClient<NodeClient>();\n        if (isAutoSessionTrackingEnabled(client)) {\n          setImmediate(() => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (client && (client as any)._captureRequestSession) {\n              // Calling _captureRequestSession to capture request session at the end of the request by incrementing\n              // the correct SessionAggregates bucket i.e. crashed, errored or exited\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n              (client as any)._captureRequestSession();\n            }\n          });\n        }\n      });\n      next();\n    });\n  };\n}\n\n/** JSDoc */\ninterface MiddlewareError extends Error {\n  status?: number | string;\n  statusCode?: number | string;\n  status_code?: number | string;\n  output?: {\n    statusCode?: number | string;\n  };\n}\n\n/** JSDoc */\nfunction getStatusCodeFromResponse(error: MiddlewareError): number {\n  const statusCode = error.status || error.statusCode || error.status_code || (error.output && error.output.statusCode);\n  return statusCode ? parseInt(statusCode as string, 10) : 500;\n}\n\n/** Returns true if response code is internal server error */\nfunction defaultShouldHandleError(error: MiddlewareError): boolean {\n  const status = getStatusCodeFromResponse(error);\n  return status >= 500;\n}\n\n/**\n * Express compatible error handler.\n * @see Exposed as `Handlers.errorHandler`\n */\nexport function errorHandler(options?: {\n  /**\n   * Callback method deciding whether error should be captured and sent to Sentry\n   * @param error Captured middleware error\n   */\n  shouldHandleError?(this: void, error: MiddlewareError): boolean;\n}): (\n  error: MiddlewareError,\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  next: (error: MiddlewareError) => void,\n) => void {\n  return function sentryErrorMiddleware(\n    error: MiddlewareError,\n    _req: http.IncomingMessage,\n    res: http.ServerResponse,\n    next: (error: MiddlewareError) => void,\n  ): void {\n    const shouldHandleError = (options && options.shouldHandleError) || defaultShouldHandleError;\n\n    if (shouldHandleError(error)) {\n      withScope(_scope => {\n        // The request should already have been stored in `scope.sdkProcessingMetadata` by `sentryRequestMiddleware`,\n        // but on the off chance someone is using `sentryErrorMiddleware` without `sentryRequestMiddleware`, it doesn't\n        // hurt to be sure\n        _scope.setSDKProcessingMetadata({ request: _req });\n\n        // For some reason we need to set the transaction on the scope again\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        const transaction = (res as any).__sentry_transaction as Span;\n        if (transaction && !getActiveSpan()) {\n          // eslint-disable-next-line deprecation/deprecation\n          _scope.setSpan(transaction);\n        }\n\n        const client = getClient<NodeClient>();\n        if (client && isAutoSessionTrackingEnabled(client)) {\n          // Check if the `SessionFlusher` is instantiated on the client to go into this branch that marks the\n          // `requestSession.status` as `Crashed`, and this check is necessary because the `SessionFlusher` is only\n          // instantiated when the the`requestHandler` middleware is initialised, which indicates that we should be\n          // running in SessionAggregates mode\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          const isSessionAggregatesMode = (client as any)._sessionFlusher !== undefined;\n          if (isSessionAggregatesMode) {\n            const requestSession = _scope.getRequestSession();\n            // If an error bubbles to the `errorHandler`, then this is an unhandled error, and should be reported as a\n            // Crashed session. The `_requestSession.status` is checked to ensure that this error is happening within\n            // the bounds of a request, and if so the status is updated\n            if (requestSession && requestSession.status !== undefined) {\n              requestSession.status = 'crashed';\n            }\n          }\n        }\n\n        const eventId = captureException(error, { mechanism: { type: 'middleware', handled: false } });\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        (res as any).sentry = eventId;\n        next(error);\n      });\n\n      return;\n    }\n\n    next(error);\n  };\n}\n\n/**\n * Sentry tRPC middleware that names the handling transaction after the called procedure.\n *\n * Use the Sentry tRPC middleware in combination with the Sentry server integration,\n * e.g. Express Request Handlers or Next.js SDK.\n *\n * @deprecated Please use the top level export instead:\n * ```\n * // OLD\n * import * as Sentry from '@sentry/node';\n * Sentry.Handlers.trpcMiddleware();\n *\n * // NEW\n * import * as Sentry from '@sentry/node';\n * Sentry.trpcMiddleware();\n * ```\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const trpcMiddleware = newTrpcMiddleware;\n\n// TODO (v8 / #5257): Remove this\n// eslint-disable-next-line deprecation/deprecation\nexport type { ParseRequestOptions, ExpressRequest } from './requestDataDeprecated';\n// eslint-disable-next-line deprecation/deprecation\nexport { parseRequest, extractRequestData } from './requestDataDeprecated';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}