{"ast":null,"code":"/**\n * Creates a rate limiter that will call the disable callback when the rate limit is reached and the enable callback\n * when a timeout has occurred.\n * @param maxPerSecond Maximum number of calls per second\n * @param enable Callback to enable capture\n * @param disable Callback to disable capture\n * @returns A function to call to increment the rate limiter count\n */\nfunction createRateLimiter(maxPerSecond, enable, disable) {\n  let count = 0;\n  let retrySeconds = 5;\n  let disabledTimeout = 0;\n  setInterval(() => {\n    if (disabledTimeout === 0) {\n      if (count > maxPerSecond) {\n        retrySeconds *= 2;\n        disable(retrySeconds);\n\n        // Cap at one day\n        if (retrySeconds > 86400) {\n          retrySeconds = 86400;\n        }\n        disabledTimeout = retrySeconds;\n      }\n    } else {\n      disabledTimeout -= 1;\n      if (disabledTimeout === 0) {\n        enable();\n      }\n    }\n    count = 0;\n  }, 1000).unref();\n  return () => {\n    count += 1;\n  };\n}\n\n// Add types for the exception event data\n\n/** Could this be an anonymous function? */\nfunction isAnonymous(name) {\n  return name !== undefined && (name.length === 0 || name === '?' || name === '<anonymous>');\n}\n\n/** Do the function names appear to match? */\nfunction functionNamesMatch(a, b) {\n  return a === b || isAnonymous(a) && isAnonymous(b);\n}\n\n/** Creates a unique hash from stack frames */\nfunction hashFrames(frames) {\n  if (frames === undefined) {\n    return;\n  }\n\n  // Only hash the 10 most recent frames (ie. the last 10)\n  return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, '');\n}\n\n/**\n * We use the stack parser to create a unique hash from the exception stack trace\n * This is used to lookup vars when the exception passes through the event processor\n */\nfunction hashFromStack(stackParser, stack) {\n  if (stack === undefined) {\n    return undefined;\n  }\n  return hashFrames(stackParser(stack, 1));\n}\nexport { createRateLimiter, functionNamesMatch, hashFrames, hashFromStack, isAnonymous };","map":{"version":3,"names":["createRateLimiter","maxPerSecond","enable","disable","count","retrySeconds","disabledTimeout","setInterval","unref","isAnonymous","name","undefined","length","functionNamesMatch","a","b","hashFrames","frames","slice","reduce","acc","frame","function","lineno","colno","hashFromStack","stackParser","stack"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\integrations\\local-variables\\common.ts"],"sourcesContent":["import type { StackFrame, StackParser } from '@sentry/types';\nimport type { Debugger } from 'inspector';\n\nexport type Variables = Record<string, unknown>;\n\nexport type RateLimitIncrement = () => void;\n\n/**\n * Creates a rate limiter that will call the disable callback when the rate limit is reached and the enable callback\n * when a timeout has occurred.\n * @param maxPerSecond Maximum number of calls per second\n * @param enable Callback to enable capture\n * @param disable Callback to disable capture\n * @returns A function to call to increment the rate limiter count\n */\nexport function createRateLimiter(\n  maxPerSecond: number,\n  enable: () => void,\n  disable: (seconds: number) => void,\n): RateLimitIncrement {\n  let count = 0;\n  let retrySeconds = 5;\n  let disabledTimeout = 0;\n\n  setInterval(() => {\n    if (disabledTimeout === 0) {\n      if (count > maxPerSecond) {\n        retrySeconds *= 2;\n        disable(retrySeconds);\n\n        // Cap at one day\n        if (retrySeconds > 86400) {\n          retrySeconds = 86400;\n        }\n        disabledTimeout = retrySeconds;\n      }\n    } else {\n      disabledTimeout -= 1;\n\n      if (disabledTimeout === 0) {\n        enable();\n      }\n    }\n\n    count = 0;\n  }, 1_000).unref();\n\n  return () => {\n    count += 1;\n  };\n}\n\n// Add types for the exception event data\nexport type PausedExceptionEvent = Debugger.PausedEventDataType & {\n  data: {\n    // This contains error.stack\n    description: string;\n  };\n};\n\n/** Could this be an anonymous function? */\nexport function isAnonymous(name: string | undefined): boolean {\n  return name !== undefined && (name.length === 0 || name === '?' || name === '<anonymous>');\n}\n\n/** Do the function names appear to match? */\nexport function functionNamesMatch(a: string | undefined, b: string | undefined): boolean {\n  return a === b || (isAnonymous(a) && isAnonymous(b));\n}\n\n/** Creates a unique hash from stack frames */\nexport function hashFrames(frames: StackFrame[] | undefined): string | undefined {\n  if (frames === undefined) {\n    return;\n  }\n\n  // Only hash the 10 most recent frames (ie. the last 10)\n  return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, '');\n}\n\n/**\n * We use the stack parser to create a unique hash from the exception stack trace\n * This is used to lookup vars when the exception passes through the event processor\n */\nexport function hashFromStack(stackParser: StackParser, stack: string | undefined): string | undefined {\n  if (stack === undefined) {\n    return undefined;\n  }\n\n  return hashFrames(stackParser(stack, 1));\n}\n\nexport interface FrameVariables {\n  function: string;\n  vars?: Variables;\n}\n\nexport interface LocalVariablesIntegrationOptions {\n  /**\n   * Capture local variables for both caught and uncaught exceptions\n   *\n   * - When false, only uncaught exceptions will have local variables\n   * - When true, both caught and uncaught exceptions will have local variables.\n   *\n   * Defaults to `true`.\n   *\n   * Capturing local variables for all exceptions can be expensive since the debugger pauses for every throw to collect\n   * local variables.\n   *\n   * To reduce the likelihood of this feature impacting app performance or throughput, this feature is rate-limited.\n   * Once the rate limit is reached, local variables will only be captured for uncaught exceptions until a timeout has\n   * been reached.\n   */\n  captureAllExceptions?: boolean;\n  /**\n   * Maximum number of exceptions to capture local variables for per second before rate limiting is triggered.\n   */\n  maxExceptionsPerSecond?: number;\n}\n"],"mappings":"AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,iBAAiBA,CAC/BC,YAAY,EACZC,MAAM,EACNC,OAAO,EACa;EACpB,IAAIC,KAAM,GAAE,CAAC;EACb,IAAIC,YAAa,GAAE,CAAC;EACpB,IAAIC,eAAgB,GAAE,CAAC;EAEvBC,WAAW,CAAC,MAAM;IAChB,IAAID,eAAgB,KAAI,CAAC,EAAE;MACzB,IAAIF,KAAM,GAAEH,YAAY,EAAE;QACxBI,YAAA,IAAgB,CAAC;QACjBF,OAAO,CAACE,YAAY,CAAC;;QAE7B;QACQ,IAAIA,YAAa,GAAE,KAAK,EAAE;UACxBA,YAAA,GAAe,KAAK;QAC9B;QACQC,eAAA,GAAkBD,YAAY;MACtC;IACA,OAAW;MACLC,eAAA,IAAmB,CAAC;MAEpB,IAAIA,eAAgB,KAAI,CAAC,EAAE;QACzBJ,MAAM,EAAE;MAChB;IACA;IAEIE,KAAA,GAAQ,CAAC;EACb,CAAG,EAAE,IAAK,CAAC,CAACI,KAAK,EAAE;EAEjB,OAAO,MAAM;IACXJ,KAAA,IAAS,CAAC;EACd,CAAG;AACH;;AAEA;;AAQA;AACO,SAASK,WAAWA,CAACC,IAAI,EAA+B;EAC7D,OAAOA,IAAK,KAAIC,SAAA,KAAcD,IAAI,CAACE,MAAA,KAAW,CAAE,IAAGF,IAAA,KAAS,OAAOA,IAAK,KAAI,aAAa,CAAC;AAC5F;;AAEA;AACO,SAASG,kBAAkBA,CAACC,CAAC,EAAsBC,CAAC,EAA+B;EACxF,OAAOD,CAAA,KAAMC,CAAA,IAAMN,WAAW,CAACK,CAAC,KAAKL,WAAW,CAACM,CAAC,CAAE;AACtD;;AAEA;AACO,SAASC,UAAUA,CAACC,MAAM,EAAgD;EAC/E,IAAIA,MAAO,KAAIN,SAAS,EAAE;IACxB;EACJ;;EAEA;EACE,OAAOM,MAAM,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAM,GAAAD,GAAA,IAAAC,KAAA,CAAAC,QAAA,IAAAD,KAAA,CAAAE,MAAA,IAAAF,KAAA,CAAAG,KAAA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAAC,cAAAC,WAAA,EAAAC,KAAA;EACA,IAAAA,KAAA,KAAAhB,SAAA;IACA,OAAAA,SAAA;EACA;EAEA,OAAAK,UAAA,CAAAU,WAAA,CAAAC,KAAA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}