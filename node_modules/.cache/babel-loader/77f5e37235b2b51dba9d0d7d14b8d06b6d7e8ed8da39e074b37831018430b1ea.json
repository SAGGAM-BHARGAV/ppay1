{"ast":null,"code":"import { defineIntegration, convertIntegrationFnToClass, getClient, captureException } from '@sentry/core';\nimport { logger } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { logAndExitProcess } from './utils/errorhandling.js';\nconst INTEGRATION_NAME = 'OnUncaughtException';\nconst _onUncaughtExceptionIntegration = (options = {}) => {\n  const _options = {\n    exitEvenIfOtherHandlersAreRegistered: true,\n    ...options\n  };\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {},\n    // eslint-disable-line @typescript-eslint/no-empty-function\n    setup(client) {\n      global.process.on('uncaughtException', makeErrorHandler(client, _options));\n    }\n  };\n};\nconst onUncaughtExceptionIntegration = defineIntegration(_onUncaughtExceptionIntegration);\n\n/**\n * Global Exception handler.\n * @deprecated Use `onUncaughtExceptionIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst OnUncaughtException = convertIntegrationFnToClass(INTEGRATION_NAME, onUncaughtExceptionIntegration);\n\n// eslint-disable-next-line deprecation/deprecation\n\n/** Exported only for tests */\nfunction makeErrorHandler(client, options) {\n  const timeout = 2000;\n  let caughtFirstError = false;\n  let caughtSecondError = false;\n  let calledFatalError = false;\n  let firstError;\n  const clientOptions = client.getOptions();\n  return Object.assign(error => {\n    let onFatalError = logAndExitProcess;\n    if (options.onFatalError) {\n      onFatalError = options.onFatalError;\n    } else if (clientOptions.onFatalError) {\n      onFatalError = clientOptions.onFatalError;\n    }\n\n    // Attaching a listener to `uncaughtException` will prevent the node process from exiting. We generally do not\n    // want to alter this behaviour so we check for other listeners that users may have attached themselves and adjust\n    // exit behaviour of the SDK accordingly:\n    // - If other listeners are attached, do not exit.\n    // - If the only listener attached is ours, exit.\n    const userProvidedListenersCount = global.process.listeners('uncaughtException').reduce((acc, listener) => {\n      if (\n      // There are 3 listeners we ignore:\n      listener.name === 'domainUncaughtExceptionClear' ||\n      // as soon as we're using domains this listener is attached by node itself\n      listener.tag && listener.tag === 'sentry_tracingErrorCallback' ||\n      // the handler we register for tracing\n      listener._errorHandler // the handler we register in this integration\n      ) {\n        return acc;\n      } else {\n        return acc + 1;\n      }\n    }, 0);\n    const processWouldExit = userProvidedListenersCount === 0;\n    const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;\n    if (!caughtFirstError) {\n      // this is the first uncaught error and the ultimate reason for shutting down\n      // we want to do absolutely everything possible to ensure it gets captured\n      // also we want to make sure we don't go recursion crazy if more errors happen after this one\n      firstError = error;\n      caughtFirstError = true;\n      if (getClient() === client) {\n        captureException(error, {\n          originalException: error,\n          captureContext: {\n            level: 'fatal'\n          },\n          mechanism: {\n            handled: false,\n            type: 'onuncaughtexception'\n          }\n        });\n      }\n      if (!calledFatalError && shouldApplyFatalHandlingLogic) {\n        calledFatalError = true;\n        onFatalError(error);\n      }\n    } else {\n      if (shouldApplyFatalHandlingLogic) {\n        if (calledFatalError) {\n          // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n          DEBUG_BUILD && logger.warn('uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown');\n          logAndExitProcess(error);\n        } else if (!caughtSecondError) {\n          // two cases for how we can hit this branch:\n          //   - capturing of first error blew up and we just caught the exception from that\n          //     - quit trying to capture, proceed with shutdown\n          //   - a second independent error happened while waiting for first error to capture\n          //     - want to avoid causing premature shutdown before first error capture finishes\n          // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n          // so let's instead just delay a bit before we proceed with our action here\n          // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n          // in case 2, the delay hopefully made us wait long enough for the capture to finish\n          // two potential nonideal outcomes:\n          //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n          //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n          // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n          //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n          caughtSecondError = true;\n          setTimeout(() => {\n            if (!calledFatalError) {\n              // it was probably case 1, let's treat err as the sendErr and call onFatalError\n              calledFatalError = true;\n              onFatalError(firstError, error);\n            }\n          }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n        }\n      }\n    }\n  }, {\n    _errorHandler: true\n  });\n}\nexport { OnUncaughtException, makeErrorHandler, onUncaughtExceptionIntegration };","map":{"version":3,"names":["INTEGRATION_NAME","_onUncaughtExceptionIntegration","options","_options","exitEvenIfOtherHandlersAreRegistered","name","setupOnce","setup","client","global","process","on","makeErrorHandler","onUncaughtExceptionIntegration","defineIntegration","OnUncaughtException","convertIntegrationFnToClass","timeout","caughtFirstError","caughtSecondError","calledFatalError","firstError","clientOptions","getOptions","Object","assign","error","onFatalError","logAndExitProcess","userProvidedListenersCount","listeners","reduce","acc","listener","tag","_errorHandler","processWouldExit","shouldApplyFatalHandlingLogic","getClient","captureException","originalException","captureContext","level","mechanism","handled","type","DEBUG_BUILD","logger","warn","setTimeout"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\integrations\\onuncaughtexception.ts"],"sourcesContent":["import { captureException, convertIntegrationFnToClass, defineIntegration } from '@sentry/core';\nimport { getClient } from '@sentry/core';\nimport type { Integration, IntegrationClass, IntegrationFn } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nimport type { NodeClient } from '../client';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { logAndExitProcess } from './utils/errorhandling';\n\ntype OnFatalErrorHandler = (firstError: Error, secondError?: Error) => void;\n\ntype TaggedListener = NodeJS.UncaughtExceptionListener & {\n  tag?: string;\n};\n\n// CAREFUL: Please think twice before updating the way _options looks because the Next.js SDK depends on it in `index.server.ts`\ninterface OnUncaughtExceptionOptions {\n  // TODO(v8): Evaluate whether we should switch the default behaviour here.\n  // Also, we can evaluate using https://nodejs.org/api/process.html#event-uncaughtexceptionmonitor per default, and\n  // falling back to current behaviour when that's not available.\n  /**\n   * Controls if the SDK should register a handler to exit the process on uncaught errors:\n   * - `true`: The SDK will exit the process on all uncaught errors.\n   * - `false`: The SDK will only exit the process when there are no other `uncaughtException` handlers attached.\n   *\n   * Default: `true`\n   */\n  exitEvenIfOtherHandlersAreRegistered: boolean;\n\n  /**\n   * This is called when an uncaught error would cause the process to exit.\n   *\n   * @param firstError Uncaught error causing the process to exit\n   * @param secondError Will be set if the handler was called multiple times. This can happen either because\n   * `onFatalError` itself threw, or because an independent error happened somewhere else while `onFatalError`\n   * was running.\n   */\n  onFatalError?(this: void, firstError: Error, secondError?: Error): void;\n}\n\nconst INTEGRATION_NAME = 'OnUncaughtException';\n\nconst _onUncaughtExceptionIntegration = ((options: Partial<OnUncaughtExceptionOptions> = {}) => {\n  const _options = {\n    exitEvenIfOtherHandlersAreRegistered: true,\n    ...options,\n  };\n\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    setup(client: NodeClient) {\n      global.process.on('uncaughtException', makeErrorHandler(client, _options));\n    },\n  };\n}) satisfies IntegrationFn;\n\nexport const onUncaughtExceptionIntegration = defineIntegration(_onUncaughtExceptionIntegration);\n\n/**\n * Global Exception handler.\n * @deprecated Use `onUncaughtExceptionIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const OnUncaughtException = convertIntegrationFnToClass(\n  INTEGRATION_NAME,\n  onUncaughtExceptionIntegration,\n) as IntegrationClass<Integration & { setup: (client: NodeClient) => void }> & {\n  new (\n    options?: Partial<{\n      exitEvenIfOtherHandlersAreRegistered: boolean;\n      onFatalError?(this: void, firstError: Error, secondError?: Error): void;\n    }>,\n  ): Integration;\n};\n\n// eslint-disable-next-line deprecation/deprecation\nexport type OnUncaughtException = typeof OnUncaughtException;\n\ntype ErrorHandler = { _errorHandler: boolean } & ((error: Error) => void);\n\n/** Exported only for tests */\nexport function makeErrorHandler(client: NodeClient, options: OnUncaughtExceptionOptions): ErrorHandler {\n  const timeout = 2000;\n  let caughtFirstError: boolean = false;\n  let caughtSecondError: boolean = false;\n  let calledFatalError: boolean = false;\n  let firstError: Error;\n\n  const clientOptions = client.getOptions();\n\n  return Object.assign(\n    (error: Error): void => {\n      let onFatalError: OnFatalErrorHandler = logAndExitProcess;\n\n      if (options.onFatalError) {\n        onFatalError = options.onFatalError;\n      } else if (clientOptions.onFatalError) {\n        onFatalError = clientOptions.onFatalError as OnFatalErrorHandler;\n      }\n\n      // Attaching a listener to `uncaughtException` will prevent the node process from exiting. We generally do not\n      // want to alter this behaviour so we check for other listeners that users may have attached themselves and adjust\n      // exit behaviour of the SDK accordingly:\n      // - If other listeners are attached, do not exit.\n      // - If the only listener attached is ours, exit.\n      const userProvidedListenersCount = (\n        global.process.listeners('uncaughtException') as TaggedListener[]\n      ).reduce<number>((acc, listener) => {\n        if (\n          // There are 3 listeners we ignore:\n          listener.name === 'domainUncaughtExceptionClear' || // as soon as we're using domains this listener is attached by node itself\n          (listener.tag && listener.tag === 'sentry_tracingErrorCallback') || // the handler we register for tracing\n          (listener as ErrorHandler)._errorHandler // the handler we register in this integration\n        ) {\n          return acc;\n        } else {\n          return acc + 1;\n        }\n      }, 0);\n\n      const processWouldExit = userProvidedListenersCount === 0;\n      const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;\n\n      if (!caughtFirstError) {\n        // this is the first uncaught error and the ultimate reason for shutting down\n        // we want to do absolutely everything possible to ensure it gets captured\n        // also we want to make sure we don't go recursion crazy if more errors happen after this one\n        firstError = error;\n        caughtFirstError = true;\n\n        if (getClient() === client) {\n          captureException(error, {\n            originalException: error,\n            captureContext: {\n              level: 'fatal',\n            },\n            mechanism: {\n              handled: false,\n              type: 'onuncaughtexception',\n            },\n          });\n        }\n\n        if (!calledFatalError && shouldApplyFatalHandlingLogic) {\n          calledFatalError = true;\n          onFatalError(error);\n        }\n      } else {\n        if (shouldApplyFatalHandlingLogic) {\n          if (calledFatalError) {\n            // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down\n            DEBUG_BUILD &&\n              logger.warn(\n                'uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown',\n              );\n            logAndExitProcess(error);\n          } else if (!caughtSecondError) {\n            // two cases for how we can hit this branch:\n            //   - capturing of first error blew up and we just caught the exception from that\n            //     - quit trying to capture, proceed with shutdown\n            //   - a second independent error happened while waiting for first error to capture\n            //     - want to avoid causing premature shutdown before first error capture finishes\n            // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff\n            // so let's instead just delay a bit before we proceed with our action here\n            // in case 1, we just wait a bit unnecessarily but ultimately do the same thing\n            // in case 2, the delay hopefully made us wait long enough for the capture to finish\n            // two potential nonideal outcomes:\n            //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError\n            //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error\n            // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)\n            //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish\n            caughtSecondError = true;\n            setTimeout(() => {\n              if (!calledFatalError) {\n                // it was probably case 1, let's treat err as the sendErr and call onFatalError\n                calledFatalError = true;\n                onFatalError(firstError, error);\n              } else {\n                // it was probably case 2, our first error finished capturing while we waited, cool, do nothing\n              }\n            }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc\n          }\n        }\n      }\n    },\n    { _errorHandler: true },\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}