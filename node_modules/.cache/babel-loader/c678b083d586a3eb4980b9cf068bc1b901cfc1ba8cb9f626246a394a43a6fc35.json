{"ast":null,"code":"import { _optionalChain } from '@sentry/utils';\nimport { defineIntegration, getClient, isSentryRequestUrl, getCurrentScope, getIsolationScope, getActiveSpan, spanToTraceHeader, getDynamicSamplingContextFromSpan, getDynamicSamplingContextFromClient, setHttpStatus, spanToJSON, hasTracingEnabled, getCurrentHub, addBreadcrumb } from '@sentry/core';\nimport { dropUndefinedKeys, logger, fill, LRUMap, generateSentryTraceHeader, dynamicSamplingContextToSentryBaggageHeader, stringMatchesSomePattern } from '@sentry/utils';\nimport { DEBUG_BUILD } from '../debug-build.js';\nimport { NODE_VERSION } from '../nodeVersion.js';\nimport { normalizeRequestArgs, extractRawUrl, extractUrl, cleanSpanDescription } from './utils/http.js';\nconst _httpIntegration = (options = {}) => {\n  const {\n    breadcrumbs,\n    tracing,\n    shouldCreateSpanForRequest\n  } = options;\n  const convertedOptions = {\n    breadcrumbs,\n    tracing: tracing === false ? false : dropUndefinedKeys({\n      // If tracing is forced to `true`, we don't want to set `enableIfHasTracingEnabled`\n      enableIfHasTracingEnabled: tracing === true ? undefined : true,\n      shouldCreateSpanForRequest\n    })\n  };\n\n  // eslint-disable-next-line deprecation/deprecation\n  return new Http(convertedOptions);\n};\n\n/**\n * The http module integration instruments Node's internal http module. It creates breadcrumbs, spans for outgoing\n * http requests, and attaches trace data when tracing is enabled via its `tracing` option.\n *\n * By default, this will always create breadcrumbs, and will create spans if tracing is enabled.\n */\nconst httpIntegration = defineIntegration(_httpIntegration);\n\n/**\n * The http module integration instruments Node's internal http module. It creates breadcrumbs, transactions for outgoing\n * http requests and attaches trace data when tracing is enabled via its `tracing` option.\n *\n * @deprecated Use `httpIntegration()` instead.\n */\nclass Http {\n  /**\n   * @inheritDoc\n   */\n  static __initStatic() {\n    this.id = 'Http';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line deprecation/deprecation\n  __init() {\n    this.name = Http.id;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  constructor(options = {}) {\n    Http.prototype.__init.call(this);\n    this._breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;\n    this._tracing = !options.tracing ? undefined : options.tracing === true ? {} : options.tracing;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setupOnce(_addGlobalEventProcessor,\n  // eslint-disable-next-line deprecation/deprecation\n  setupOnceGetCurrentHub) {\n    // eslint-disable-next-line deprecation/deprecation\n    const clientOptions = _optionalChain([setupOnceGetCurrentHub, 'call', _ => _(), 'access', _2 => _2.getClient, 'call', _3 => _3(), 'optionalAccess', _4 => _4.getOptions, 'call', _5 => _5()]);\n\n    // If `tracing` is not explicitly set, we default this based on whether or not tracing is enabled.\n    // But for compatibility, we only do that if `enableIfHasTracingEnabled` is set.\n    const shouldCreateSpans = _shouldCreateSpans(this._tracing, clientOptions);\n\n    // No need to instrument if we don't want to track anything\n    if (!this._breadcrumbs && !shouldCreateSpans) {\n      return;\n    }\n\n    // Do not auto-instrument for other instrumenter\n    if (clientOptions && clientOptions.instrumenter !== 'sentry') {\n      DEBUG_BUILD && logger.log('HTTP Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n    const shouldCreateSpanForRequest = _getShouldCreateSpanForRequest(shouldCreateSpans, this._tracing, clientOptions);\n\n    // eslint-disable-next-line deprecation/deprecation\n    const tracePropagationTargets = _optionalChain([clientOptions, 'optionalAccess', _6 => _6.tracePropagationTargets]) || _optionalChain([this, 'access', _7 => _7._tracing, 'optionalAccess', _8 => _8.tracePropagationTargets]);\n\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const httpModule = require('http');\n    const wrappedHttpHandlerMaker = _createWrappedRequestMethodFactory(httpModule, this._breadcrumbs, shouldCreateSpanForRequest, tracePropagationTargets);\n    fill(httpModule, 'get', wrappedHttpHandlerMaker);\n    fill(httpModule, 'request', wrappedHttpHandlerMaker);\n\n    // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.\n    // If we do, we'd get double breadcrumbs and double spans for `https` calls.\n    // It has been changed in Node 9, so for all versions equal and above, we patch `https` separately.\n    if (NODE_VERSION.major > 8) {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const httpsModule = require('https');\n      const wrappedHttpsHandlerMaker = _createWrappedRequestMethodFactory(httpsModule, this._breadcrumbs, shouldCreateSpanForRequest, tracePropagationTargets);\n      fill(httpsModule, 'get', wrappedHttpsHandlerMaker);\n      fill(httpsModule, 'request', wrappedHttpsHandlerMaker);\n    }\n  }\n}\nHttp.__initStatic();\n\n// for ease of reading below\n\n/**\n * Function which creates a function which creates wrapped versions of internal `request` and `get` calls within `http`\n * and `https` modules. (NB: Not a typo - this is a creator^2!)\n *\n * @param breadcrumbsEnabled Whether or not to record outgoing requests as breadcrumbs\n * @param tracingEnabled Whether or not to record outgoing requests as tracing spans\n *\n * @returns A function which accepts the exiting handler and returns a wrapped handler\n */\nfunction _createWrappedRequestMethodFactory(httpModule, breadcrumbsEnabled, shouldCreateSpanForRequest, tracePropagationTargets) {\n  // We're caching results so we don't have to recompute regexp every time we create a request.\n  const createSpanUrlMap = new LRUMap(100);\n  const headersUrlMap = new LRUMap(100);\n  const shouldCreateSpan = url => {\n    if (shouldCreateSpanForRequest === undefined) {\n      return true;\n    }\n    const cachedDecision = createSpanUrlMap.get(url);\n    if (cachedDecision !== undefined) {\n      return cachedDecision;\n    }\n    const decision = shouldCreateSpanForRequest(url);\n    createSpanUrlMap.set(url, decision);\n    return decision;\n  };\n  const shouldAttachTraceData = url => {\n    if (tracePropagationTargets === undefined) {\n      return true;\n    }\n    const cachedDecision = headersUrlMap.get(url);\n    if (cachedDecision !== undefined) {\n      return cachedDecision;\n    }\n    const decision = stringMatchesSomePattern(url, tracePropagationTargets);\n    headersUrlMap.set(url, decision);\n    return decision;\n  };\n\n  /**\n   * Captures Breadcrumb based on provided request/response pair\n   */\n  function addRequestBreadcrumb(event, requestSpanData, req, res) {\n    // eslint-disable-next-line deprecation/deprecation\n    if (!getCurrentHub().getIntegration(Http)) {\n      return;\n    }\n    addBreadcrumb({\n      category: 'http',\n      data: {\n        status_code: res && res.statusCode,\n        ...requestSpanData\n      },\n      type: 'http'\n    }, {\n      event,\n      request: req,\n      response: res\n    });\n  }\n  return function wrappedRequestMethodFactory(originalRequestMethod) {\n    return function wrappedMethod(...args) {\n      const requestArgs = normalizeRequestArgs(httpModule, args);\n      const requestOptions = requestArgs[0];\n      // eslint-disable-next-line deprecation/deprecation\n      const rawRequestUrl = extractRawUrl(requestOptions);\n      const requestUrl = extractUrl(requestOptions);\n      const client = getClient();\n\n      // we don't want to record requests to Sentry as either breadcrumbs or spans, so just use the original method\n      if (isSentryRequestUrl(requestUrl, client)) {\n        return originalRequestMethod.apply(httpModule, requestArgs);\n      }\n      const scope = getCurrentScope();\n      const isolationScope = getIsolationScope();\n      const parentSpan = getActiveSpan();\n      const data = getRequestSpanData(requestUrl, requestOptions);\n      const requestSpan = shouldCreateSpan(rawRequestUrl) ?\n      // eslint-disable-next-line deprecation/deprecation\n      _optionalChain([parentSpan, 'optionalAccess', _9 => _9.startChild, 'call', _10 => _10({\n        op: 'http.client',\n        origin: 'auto.http.node.http',\n        description: `${data['http.method']} ${data.url}`,\n        data\n      })]) : undefined;\n      if (client && shouldAttachTraceData(rawRequestUrl)) {\n        const {\n          traceId,\n          spanId,\n          sampled,\n          dsc\n        } = {\n          ...isolationScope.getPropagationContext(),\n          ...scope.getPropagationContext()\n        };\n        const sentryTraceHeader = requestSpan ? spanToTraceHeader(requestSpan) : generateSentryTraceHeader(traceId, spanId, sampled);\n        const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dsc || (requestSpan ? getDynamicSamplingContextFromSpan(requestSpan) : getDynamicSamplingContextFromClient(traceId, client, scope)));\n        addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader);\n      } else {\n        DEBUG_BUILD && logger.log(`[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalRequestMethod.apply(httpModule, requestArgs).once('response', function (res) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const req = this;\n        if (breadcrumbsEnabled) {\n          addRequestBreadcrumb('response', data, req, res);\n        }\n        if (requestSpan) {\n          if (res.statusCode) {\n            setHttpStatus(requestSpan, res.statusCode);\n          }\n          requestSpan.updateName(cleanSpanDescription(spanToJSON(requestSpan).description || '', requestOptions, req) || '');\n          requestSpan.end();\n        }\n      }).once('error', function () {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const req = this;\n        if (breadcrumbsEnabled) {\n          addRequestBreadcrumb('error', data, req);\n        }\n        if (requestSpan) {\n          setHttpStatus(requestSpan, 500);\n          requestSpan.updateName(cleanSpanDescription(spanToJSON(requestSpan).description || '', requestOptions, req) || '');\n          requestSpan.end();\n        }\n      });\n    };\n  };\n}\nfunction addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader) {\n  // Don't overwrite sentry-trace and baggage header if it's already set.\n  const headers = requestOptions.headers || {};\n  if (headers['sentry-trace']) {\n    return;\n  }\n  DEBUG_BUILD && logger.log(`[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to \"${requestUrl}\": `);\n  requestOptions.headers = {\n    ...requestOptions.headers,\n    'sentry-trace': sentryTraceHeader,\n    // Setting a header to `undefined` will crash in node so we only set the baggage header when it's defined\n    ...(sentryBaggageHeader && sentryBaggageHeader.length > 0 && {\n      baggage: normalizeBaggageHeader(requestOptions, sentryBaggageHeader)\n    })\n  };\n}\nfunction getRequestSpanData(requestUrl, requestOptions) {\n  const method = requestOptions.method || 'GET';\n  const data = {\n    url: requestUrl,\n    'http.method': method\n  };\n  if (requestOptions.hash) {\n    // strip leading \"#\"\n    data['http.fragment'] = requestOptions.hash.substring(1);\n  }\n  if (requestOptions.search) {\n    // strip leading \"?\"\n    data['http.query'] = requestOptions.search.substring(1);\n  }\n  return data;\n}\nfunction normalizeBaggageHeader(requestOptions, sentryBaggageHeader) {\n  if (!requestOptions.headers || !requestOptions.headers.baggage) {\n    return sentryBaggageHeader;\n  } else if (!sentryBaggageHeader) {\n    return requestOptions.headers.baggage;\n  } else if (Array.isArray(requestOptions.headers.baggage)) {\n    return [...requestOptions.headers.baggage, sentryBaggageHeader];\n  }\n  // Type-cast explanation:\n  // Technically this the following could be of type `(number | string)[]` but for the sake of simplicity\n  // we say this is undefined behaviour, since it would not be baggage spec conform if the user did this.\n  return [requestOptions.headers.baggage, sentryBaggageHeader];\n}\n\n/** Exported for tests only. */\nfunction _shouldCreateSpans(tracingOptions, clientOptions) {\n  return tracingOptions === undefined ? false : tracingOptions.enableIfHasTracingEnabled ? hasTracingEnabled(clientOptions) : true;\n}\n\n/** Exported for tests only. */\nfunction _getShouldCreateSpanForRequest(shouldCreateSpans, tracingOptions, clientOptions) {\n  const handler = shouldCreateSpans ?\n  // eslint-disable-next-line deprecation/deprecation\n  _optionalChain([tracingOptions, 'optionalAccess', _11 => _11.shouldCreateSpanForRequest]) || _optionalChain([clientOptions, 'optionalAccess', _12 => _12.shouldCreateSpanForRequest]) : () => false;\n  return handler;\n}\nexport { Http, _getShouldCreateSpanForRequest, _shouldCreateSpans, httpIntegration };","map":{"version":3,"names":["_httpIntegration","options","breadcrumbs","tracing","shouldCreateSpanForRequest","convertedOptions","dropUndefinedKeys","enableIfHasTracingEnabled","undefined","Http","httpIntegration","defineIntegration","__initStatic","id","name","constructor","prototype","__init","call","_breadcrumbs","_tracing","setupOnce","_addGlobalEventProcessor","setupOnceGetCurrentHub","clientOptions","_optionalChain","_","_2","getClient","_3","_4","getOptions","_5","shouldCreateSpans","_shouldCreateSpans","instrumenter","DEBUG_BUILD","logger","log","_getShouldCreateSpanForRequest","tracePropagationTargets","_6","_7","_8","httpModule","require","wrappedHttpHandlerMaker","_createWrappedRequestMethodFactory","fill","NODE_VERSION","major","httpsModule","wrappedHttpsHandlerMaker","breadcrumbsEnabled","createSpanUrlMap","LRUMap","headersUrlMap","shouldCreateSpan","url","cachedDecision","get","decision","set","shouldAttachTraceData","stringMatchesSomePattern","addRequestBreadcrumb","event","requestSpanData","req","res","getCurrentHub","getIntegration","addBreadcrumb","category","data","status_code","statusCode","type","request","response","wrappedRequestMethodFactory","originalRequestMethod","wrappedMethod","args","requestArgs","normalizeRequestArgs","requestOptions","rawRequestUrl","extractRawUrl","requestUrl","extractUrl","client","isSentryRequestUrl","apply","scope","getCurrentScope","isolationScope","getIsolationScope","parentSpan","getActiveSpan","getRequestSpanData","requestSpan","_9","startChild","_10","op","origin","description","traceId","spanId","sampled","dsc","getPropagationContext","sentryTraceHeader","spanToTraceHeader","generateSentryTraceHeader","sentryBaggageHeader","dynamicSamplingContextToSentryBaggageHeader","getDynamicSamplingContextFromSpan","getDynamicSamplingContextFromClient","addHeadersToRequestOptions","once","setHttpStatus","updateName","cleanSpanDescription","spanToJSON","end","headers","length","baggage","normalizeBaggageHeader","method","hash","substring","search","Array","isArray","tracingOptions","hasTracingEnabled","handler","_11","_12"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\integrations\\http.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type * as http from 'http';\nimport type * as https from 'https';\nimport type { Hub } from '@sentry/core';\nimport { defineIntegration, getIsolationScope, hasTracingEnabled } from '@sentry/core';\nimport {\n  addBreadcrumb,\n  getActiveSpan,\n  getClient,\n  getCurrentHub,\n  getCurrentScope,\n  getDynamicSamplingContextFromClient,\n  getDynamicSamplingContextFromSpan,\n  isSentryRequestUrl,\n  setHttpStatus,\n  spanToJSON,\n  spanToTraceHeader,\n} from '@sentry/core';\nimport type {\n  ClientOptions,\n  EventProcessor,\n  Integration,\n  IntegrationFn,\n  IntegrationFnResult,\n  SanitizedRequestData,\n  TracePropagationTargets,\n} from '@sentry/types';\nimport {\n  LRUMap,\n  dropUndefinedKeys,\n  dynamicSamplingContextToSentryBaggageHeader,\n  fill,\n  generateSentryTraceHeader,\n  logger,\n  stringMatchesSomePattern,\n} from '@sentry/utils';\n\nimport type { NodeClient } from '../client';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { NODE_VERSION } from '../nodeVersion';\nimport type { NodeClientOptions } from '../types';\nimport type { RequestMethod, RequestMethodArgs, RequestOptions } from './utils/http';\nimport { cleanSpanDescription, extractRawUrl, extractUrl, normalizeRequestArgs } from './utils/http';\n\ninterface TracingOptions {\n  /**\n   * List of strings/regex controlling to which outgoing requests\n   * the SDK will attach tracing headers.\n   *\n   * By default the SDK will attach those headers to all outgoing\n   * requests. If this option is provided, the SDK will match the\n   * request URL of outgoing requests against the items in this\n   * array, and only attach tracing headers if a match was found.\n   *\n   * @deprecated Use top level `tracePropagationTargets` option instead.\n   * This option will be removed in v8.\n   *\n   * ```\n   * Sentry.init({\n   *   tracePropagationTargets: ['api.site.com'],\n   * })\n   */\n  tracePropagationTargets?: TracePropagationTargets;\n\n  /**\n   * Function determining whether or not to create spans to track outgoing requests to the given URL.\n   * By default, spans will be created for all outgoing requests.\n   */\n  shouldCreateSpanForRequest?: (url: string) => boolean;\n\n  /**\n   * This option is just for compatibility with v7.\n   * In v8, this will be the default behavior.\n   */\n  enableIfHasTracingEnabled?: boolean;\n}\n\ninterface HttpOptions {\n  /**\n   * Whether breadcrumbs should be recorded for requests\n   * Defaults to true\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * Whether tracing spans should be created for requests\n   * Defaults to false\n   */\n  tracing?: TracingOptions | boolean;\n}\n\n/* These are the newer options for `httpIntegration`. */\ninterface HttpIntegrationOptions {\n  /**\n   * Whether breadcrumbs should be recorded for requests\n   * Defaults to true.\n   */\n  breadcrumbs?: boolean;\n\n  /**\n   * Whether tracing spans should be created for requests\n   * If not set, this will be enabled/disabled based on if tracing is enabled.\n   */\n  tracing?: boolean;\n\n  /**\n   * Function determining whether or not to create spans to track outgoing requests to the given URL.\n   * By default, spans will be created for all outgoing requests.\n   */\n  shouldCreateSpanForRequest?: (url: string) => boolean;\n}\n\nconst _httpIntegration = ((options: HttpIntegrationOptions = {}) => {\n  const { breadcrumbs, tracing, shouldCreateSpanForRequest } = options;\n\n  const convertedOptions: HttpOptions = {\n    breadcrumbs,\n    tracing:\n      tracing === false\n        ? false\n        : dropUndefinedKeys({\n            // If tracing is forced to `true`, we don't want to set `enableIfHasTracingEnabled`\n            enableIfHasTracingEnabled: tracing === true ? undefined : true,\n            shouldCreateSpanForRequest,\n          }),\n  };\n\n  // eslint-disable-next-line deprecation/deprecation\n  return new Http(convertedOptions) as unknown as IntegrationFnResult;\n}) satisfies IntegrationFn;\n\n/**\n * The http module integration instruments Node's internal http module. It creates breadcrumbs, spans for outgoing\n * http requests, and attaches trace data when tracing is enabled via its `tracing` option.\n *\n * By default, this will always create breadcrumbs, and will create spans if tracing is enabled.\n */\nexport const httpIntegration = defineIntegration(_httpIntegration);\n\n/**\n * The http module integration instruments Node's internal http module. It creates breadcrumbs, transactions for outgoing\n * http requests and attaches trace data when tracing is enabled via its `tracing` option.\n *\n * @deprecated Use `httpIntegration()` instead.\n */\nexport class Http implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Http';\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line deprecation/deprecation\n  public name: string = Http.id;\n\n  private readonly _breadcrumbs: boolean;\n  private readonly _tracing: TracingOptions | undefined;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: HttpOptions = {}) {\n    this._breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;\n    this._tracing = !options.tracing ? undefined : options.tracing === true ? {} : options.tracing;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(\n    _addGlobalEventProcessor: (callback: EventProcessor) => void,\n    // eslint-disable-next-line deprecation/deprecation\n    setupOnceGetCurrentHub: () => Hub,\n  ): void {\n    // eslint-disable-next-line deprecation/deprecation\n    const clientOptions = setupOnceGetCurrentHub().getClient<NodeClient>()?.getOptions();\n\n    // If `tracing` is not explicitly set, we default this based on whether or not tracing is enabled.\n    // But for compatibility, we only do that if `enableIfHasTracingEnabled` is set.\n    const shouldCreateSpans = _shouldCreateSpans(this._tracing, clientOptions);\n\n    // No need to instrument if we don't want to track anything\n    if (!this._breadcrumbs && !shouldCreateSpans) {\n      return;\n    }\n\n    // Do not auto-instrument for other instrumenter\n    if (clientOptions && clientOptions.instrumenter !== 'sentry') {\n      DEBUG_BUILD && logger.log('HTTP Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n\n    const shouldCreateSpanForRequest = _getShouldCreateSpanForRequest(shouldCreateSpans, this._tracing, clientOptions);\n\n    // eslint-disable-next-line deprecation/deprecation\n    const tracePropagationTargets = clientOptions?.tracePropagationTargets || this._tracing?.tracePropagationTargets;\n\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const httpModule = require('http');\n    const wrappedHttpHandlerMaker = _createWrappedRequestMethodFactory(\n      httpModule,\n      this._breadcrumbs,\n      shouldCreateSpanForRequest,\n      tracePropagationTargets,\n    );\n    fill(httpModule, 'get', wrappedHttpHandlerMaker);\n    fill(httpModule, 'request', wrappedHttpHandlerMaker);\n\n    // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.\n    // If we do, we'd get double breadcrumbs and double spans for `https` calls.\n    // It has been changed in Node 9, so for all versions equal and above, we patch `https` separately.\n    if (NODE_VERSION.major > 8) {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const httpsModule = require('https');\n      const wrappedHttpsHandlerMaker = _createWrappedRequestMethodFactory(\n        httpsModule,\n        this._breadcrumbs,\n        shouldCreateSpanForRequest,\n        tracePropagationTargets,\n      );\n      fill(httpsModule, 'get', wrappedHttpsHandlerMaker);\n      fill(httpsModule, 'request', wrappedHttpsHandlerMaker);\n    }\n  }\n}\n\n// for ease of reading below\ntype OriginalRequestMethod = RequestMethod;\ntype WrappedRequestMethod = RequestMethod;\ntype WrappedRequestMethodFactory = (original: OriginalRequestMethod) => WrappedRequestMethod;\n\n/**\n * Function which creates a function which creates wrapped versions of internal `request` and `get` calls within `http`\n * and `https` modules. (NB: Not a typo - this is a creator^2!)\n *\n * @param breadcrumbsEnabled Whether or not to record outgoing requests as breadcrumbs\n * @param tracingEnabled Whether or not to record outgoing requests as tracing spans\n *\n * @returns A function which accepts the exiting handler and returns a wrapped handler\n */\nfunction _createWrappedRequestMethodFactory(\n  httpModule: typeof http | typeof https,\n  breadcrumbsEnabled: boolean,\n  shouldCreateSpanForRequest: ((url: string) => boolean) | undefined,\n  tracePropagationTargets: TracePropagationTargets | undefined,\n): WrappedRequestMethodFactory {\n  // We're caching results so we don't have to recompute regexp every time we create a request.\n  const createSpanUrlMap = new LRUMap<string, boolean>(100);\n  const headersUrlMap = new LRUMap<string, boolean>(100);\n\n  const shouldCreateSpan = (url: string): boolean => {\n    if (shouldCreateSpanForRequest === undefined) {\n      return true;\n    }\n\n    const cachedDecision = createSpanUrlMap.get(url);\n    if (cachedDecision !== undefined) {\n      return cachedDecision;\n    }\n\n    const decision = shouldCreateSpanForRequest(url);\n    createSpanUrlMap.set(url, decision);\n    return decision;\n  };\n\n  const shouldAttachTraceData = (url: string): boolean => {\n    if (tracePropagationTargets === undefined) {\n      return true;\n    }\n\n    const cachedDecision = headersUrlMap.get(url);\n    if (cachedDecision !== undefined) {\n      return cachedDecision;\n    }\n\n    const decision = stringMatchesSomePattern(url, tracePropagationTargets);\n    headersUrlMap.set(url, decision);\n    return decision;\n  };\n\n  /**\n   * Captures Breadcrumb based on provided request/response pair\n   */\n  function addRequestBreadcrumb(\n    event: string,\n    requestSpanData: SanitizedRequestData,\n    req: http.ClientRequest,\n    res?: http.IncomingMessage,\n  ): void {\n    // eslint-disable-next-line deprecation/deprecation\n    if (!getCurrentHub().getIntegration(Http)) {\n      return;\n    }\n\n    addBreadcrumb(\n      {\n        category: 'http',\n        data: {\n          status_code: res && res.statusCode,\n          ...requestSpanData,\n        },\n        type: 'http',\n      },\n      {\n        event,\n        request: req,\n        response: res,\n      },\n    );\n  }\n\n  return function wrappedRequestMethodFactory(originalRequestMethod: OriginalRequestMethod): WrappedRequestMethod {\n    return function wrappedMethod(this: unknown, ...args: RequestMethodArgs): http.ClientRequest {\n      const requestArgs = normalizeRequestArgs(httpModule, args);\n      const requestOptions = requestArgs[0];\n      // eslint-disable-next-line deprecation/deprecation\n      const rawRequestUrl = extractRawUrl(requestOptions);\n      const requestUrl = extractUrl(requestOptions);\n      const client = getClient();\n\n      // we don't want to record requests to Sentry as either breadcrumbs or spans, so just use the original method\n      if (isSentryRequestUrl(requestUrl, client)) {\n        return originalRequestMethod.apply(httpModule, requestArgs);\n      }\n\n      const scope = getCurrentScope();\n      const isolationScope = getIsolationScope();\n      const parentSpan = getActiveSpan();\n\n      const data = getRequestSpanData(requestUrl, requestOptions);\n\n      const requestSpan = shouldCreateSpan(rawRequestUrl)\n        ? // eslint-disable-next-line deprecation/deprecation\n          parentSpan?.startChild({\n            op: 'http.client',\n            origin: 'auto.http.node.http',\n            description: `${data['http.method']} ${data.url}`,\n            data,\n          })\n        : undefined;\n\n      if (client && shouldAttachTraceData(rawRequestUrl)) {\n        const { traceId, spanId, sampled, dsc } = {\n          ...isolationScope.getPropagationContext(),\n          ...scope.getPropagationContext(),\n        };\n\n        const sentryTraceHeader = requestSpan\n          ? spanToTraceHeader(requestSpan)\n          : generateSentryTraceHeader(traceId, spanId, sampled);\n\n        const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(\n          dsc ||\n            (requestSpan\n              ? getDynamicSamplingContextFromSpan(requestSpan)\n              : getDynamicSamplingContextFromClient(traceId, client, scope)),\n        );\n\n        addHeadersToRequestOptions(requestOptions, requestUrl, sentryTraceHeader, sentryBaggageHeader);\n      } else {\n        DEBUG_BUILD &&\n          logger.log(\n            `[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`,\n          );\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalRequestMethod\n        .apply(httpModule, requestArgs)\n        .once('response', function (this: http.ClientRequest, res: http.IncomingMessage): void {\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const req = this;\n          if (breadcrumbsEnabled) {\n            addRequestBreadcrumb('response', data, req, res);\n          }\n          if (requestSpan) {\n            if (res.statusCode) {\n              setHttpStatus(requestSpan, res.statusCode);\n            }\n            requestSpan.updateName(\n              cleanSpanDescription(spanToJSON(requestSpan).description || '', requestOptions, req) || '',\n            );\n            requestSpan.end();\n          }\n        })\n        .once('error', function (this: http.ClientRequest): void {\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const req = this;\n\n          if (breadcrumbsEnabled) {\n            addRequestBreadcrumb('error', data, req);\n          }\n          if (requestSpan) {\n            setHttpStatus(requestSpan, 500);\n            requestSpan.updateName(\n              cleanSpanDescription(spanToJSON(requestSpan).description || '', requestOptions, req) || '',\n            );\n            requestSpan.end();\n          }\n        });\n    };\n  };\n}\n\nfunction addHeadersToRequestOptions(\n  requestOptions: RequestOptions,\n  requestUrl: string,\n  sentryTraceHeader: string,\n  sentryBaggageHeader: string | undefined,\n): void {\n  // Don't overwrite sentry-trace and baggage header if it's already set.\n  const headers = requestOptions.headers || {};\n  if (headers['sentry-trace']) {\n    return;\n  }\n\n  DEBUG_BUILD &&\n    logger.log(`[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to \"${requestUrl}\": `);\n\n  requestOptions.headers = {\n    ...requestOptions.headers,\n    'sentry-trace': sentryTraceHeader,\n    // Setting a header to `undefined` will crash in node so we only set the baggage header when it's defined\n    ...(sentryBaggageHeader &&\n      sentryBaggageHeader.length > 0 && { baggage: normalizeBaggageHeader(requestOptions, sentryBaggageHeader) }),\n  };\n}\n\nfunction getRequestSpanData(requestUrl: string, requestOptions: RequestOptions): SanitizedRequestData {\n  const method = requestOptions.method || 'GET';\n  const data: SanitizedRequestData = {\n    url: requestUrl,\n    'http.method': method,\n  };\n  if (requestOptions.hash) {\n    // strip leading \"#\"\n    data['http.fragment'] = requestOptions.hash.substring(1);\n  }\n  if (requestOptions.search) {\n    // strip leading \"?\"\n    data['http.query'] = requestOptions.search.substring(1);\n  }\n  return data;\n}\n\nfunction normalizeBaggageHeader(\n  requestOptions: RequestOptions,\n  sentryBaggageHeader: string | undefined,\n): string | string[] | undefined {\n  if (!requestOptions.headers || !requestOptions.headers.baggage) {\n    return sentryBaggageHeader;\n  } else if (!sentryBaggageHeader) {\n    return requestOptions.headers.baggage as string | string[];\n  } else if (Array.isArray(requestOptions.headers.baggage)) {\n    return [...requestOptions.headers.baggage, sentryBaggageHeader];\n  }\n  // Type-cast explanation:\n  // Technically this the following could be of type `(number | string)[]` but for the sake of simplicity\n  // we say this is undefined behaviour, since it would not be baggage spec conform if the user did this.\n  return [requestOptions.headers.baggage, sentryBaggageHeader] as string[];\n}\n\n/** Exported for tests only. */\nexport function _shouldCreateSpans(\n  tracingOptions: TracingOptions | undefined,\n  clientOptions: Partial<ClientOptions> | undefined,\n): boolean {\n  return tracingOptions === undefined\n    ? false\n    : tracingOptions.enableIfHasTracingEnabled\n      ? hasTracingEnabled(clientOptions)\n      : true;\n}\n\n/** Exported for tests only. */\nexport function _getShouldCreateSpanForRequest(\n  shouldCreateSpans: boolean,\n  tracingOptions: TracingOptions | undefined,\n  clientOptions: Partial<NodeClientOptions> | undefined,\n): undefined | ((url: string) => boolean) {\n  const handler = shouldCreateSpans\n    ? // eslint-disable-next-line deprecation/deprecation\n      tracingOptions?.shouldCreateSpanForRequest || clientOptions?.shouldCreateSpanForRequest\n    : () => false;\n\n  return handler;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}