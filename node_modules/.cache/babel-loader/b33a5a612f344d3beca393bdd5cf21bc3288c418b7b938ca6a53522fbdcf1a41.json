{"ast":null,"code":"import { _optionalChain } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { defineIntegration, convertIntegrationFnToClass } from '@sentry/core';\nimport { LRUMap, addContextToFrame } from '@sentry/utils';\nconst FILE_CONTENT_CACHE = new LRUMap(100);\nconst DEFAULT_LINES_OF_CONTEXT = 7;\nconst INTEGRATION_NAME = 'ContextLines';\n\n// TODO: Replace with promisify when minimum supported node >= v8\nfunction readTextFileAsync(path) {\n  return new Promise((resolve, reject) => {\n    readFile(path, 'utf8', (err, data) => {\n      if (err) reject(err);else resolve(data);\n    });\n  });\n}\nconst _contextLinesIntegration = (options = {}) => {\n  const contextLines = options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {},\n    // eslint-disable-line @typescript-eslint/no-empty-function\n    processEvent(event) {\n      return addSourceContext(event, contextLines);\n    }\n  };\n};\nconst contextLinesIntegration = defineIntegration(_contextLinesIntegration);\n\n/**\n * Add node modules / packages to the event.\n * @deprecated Use `contextLinesIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst ContextLines = convertIntegrationFnToClass(INTEGRATION_NAME, contextLinesIntegration);\nasync function addSourceContext(event, contextLines) {\n  // keep a lookup map of which files we've already enqueued to read,\n  // so we don't enqueue the same file multiple times which would cause multiple i/o reads\n  const enqueuedReadSourceFileTasks = {};\n  const readSourceFileTasks = [];\n  if (contextLines > 0 && _optionalChain([event, 'access', _2 => _2.exception, 'optionalAccess', _3 => _3.values])) {\n    for (const exception of event.exception.values) {\n      if (!_optionalChain([exception, 'access', _4 => _4.stacktrace, 'optionalAccess', _5 => _5.frames])) {\n        continue;\n      }\n\n      // We want to iterate in reverse order as calling cache.get will bump the file in our LRU cache.\n      // This ends up prioritizes source context for frames at the top of the stack instead of the bottom.\n      for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {\n        const frame = exception.stacktrace.frames[i];\n        // Call cache.get to bump the file to the top of the cache and ensure we have not already\n        // enqueued a read operation for this filename\n        if (frame.filename && !enqueuedReadSourceFileTasks[frame.filename] && !FILE_CONTENT_CACHE.get(frame.filename)) {\n          readSourceFileTasks.push(_readSourceFile(frame.filename));\n          enqueuedReadSourceFileTasks[frame.filename] = 1;\n        }\n      }\n    }\n  }\n\n  // check if files to read > 0, if so, await all of them to be read before adding source contexts.\n  // Normally, Promise.all here could be short circuited if one of the promises rejects, but we\n  // are guarding from that by wrapping the i/o read operation in a try/catch.\n  if (readSourceFileTasks.length > 0) {\n    await Promise.all(readSourceFileTasks);\n  }\n\n  // Perform the same loop as above, but this time we can assume all files are in the cache\n  // and attempt to add source context to frames.\n  if (contextLines > 0 && _optionalChain([event, 'access', _6 => _6.exception, 'optionalAccess', _7 => _7.values])) {\n    for (const exception of event.exception.values) {\n      if (exception.stacktrace && exception.stacktrace.frames) {\n        await addSourceContextToFrames(exception.stacktrace.frames, contextLines);\n      }\n    }\n  }\n  return event;\n}\n\n/** Adds context lines to frames */\nfunction addSourceContextToFrames(frames, contextLines) {\n  for (const frame of frames) {\n    // Only add context if we have a filename and it hasn't already been added\n    if (frame.filename && frame.context_line === undefined) {\n      const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);\n      if (sourceFileLines) {\n        try {\n          addContextToFrame(sourceFileLines, frame, contextLines);\n        } catch (e) {\n          // anomaly, being defensive in case\n          // unlikely to ever happen in practice but can definitely happen in theory\n        }\n      }\n    }\n  }\n}\n\n// eslint-disable-next-line deprecation/deprecation\n\n/**\n * Reads file contents and caches them in a global LRU cache.\n * If reading fails, mark the file as null in the cache so we don't try again.\n *\n * @param filename filepath to read content from.\n */\nasync function _readSourceFile(filename) {\n  const cachedFile = FILE_CONTENT_CACHE.get(filename);\n\n  // We have already attempted to read this file and failed, do not try again\n  if (cachedFile === null) {\n    return null;\n  }\n\n  // We have a cache hit, return it\n  if (cachedFile !== undefined) {\n    return cachedFile;\n  }\n\n  // Guard from throwing if readFile fails, this enables us to use Promise.all and\n  // not have it short circuiting if one of the promises rejects + since context lines are added\n  // on a best effort basis, we want to throw here anyways.\n\n  // If we made it to here, it means that our file is not cache nor marked as failed, so attempt to read it\n  let content = null;\n  try {\n    const rawFileContents = await readTextFileAsync(filename);\n    content = rawFileContents.split('\\n');\n  } catch (_) {\n    // if we fail, we will mark the file as null in the cache and short circuit next time we try to read it\n  }\n  FILE_CONTENT_CACHE.set(filename, content);\n  return content;\n}\nexport { ContextLines, contextLinesIntegration };","map":{"version":3,"names":["FILE_CONTENT_CACHE","LRUMap","DEFAULT_LINES_OF_CONTEXT","INTEGRATION_NAME","readTextFileAsync","path","Promise","resolve","reject","readFile","err","data","_contextLinesIntegration","options","contextLines","frameContextLines","undefined","name","setupOnce","processEvent","event","addSourceContext","contextLinesIntegration","defineIntegration","ContextLines","convertIntegrationFnToClass","enqueuedReadSourceFileTasks","readSourceFileTasks","_optionalChain","_2","exception","_3","values","_4","stacktrace","_5","frames","i","length","frame","filename","get","push","_readSourceFile","all","_6","_7","addSourceContextToFrames","context_line","sourceFileLines","addContextToFrame","e","cachedFile","content","rawFileContents","split","_","set"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\integrations\\contextlines.ts"],"sourcesContent":["import { readFile } from 'fs';\nimport { convertIntegrationFnToClass, defineIntegration } from '@sentry/core';\nimport type { Event, Integration, IntegrationClass, IntegrationFn, StackFrame } from '@sentry/types';\nimport { LRUMap, addContextToFrame } from '@sentry/utils';\n\nconst FILE_CONTENT_CACHE = new LRUMap<string, string[] | null>(100);\nconst DEFAULT_LINES_OF_CONTEXT = 7;\nconst INTEGRATION_NAME = 'ContextLines';\n\n// TODO: Replace with promisify when minimum supported node >= v8\nfunction readTextFileAsync(path: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    readFile(path, 'utf8', (err, data) => {\n      if (err) reject(err);\n      else resolve(data);\n    });\n  });\n}\n\n/**\n * Resets the file cache. Exists for testing purposes.\n * @hidden\n */\nexport function resetFileContentCache(): void {\n  FILE_CONTENT_CACHE.clear();\n}\n\ninterface ContextLinesOptions {\n  /**\n   * Sets the number of context lines for each frame when loading a file.\n   * Defaults to 7.\n   *\n   * Set to 0 to disable loading and inclusion of source files.\n   **/\n  frameContextLines?: number;\n}\n\nconst _contextLinesIntegration = ((options: ContextLinesOptions = {}) => {\n  const contextLines = options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    processEvent(event) {\n      return addSourceContext(event, contextLines);\n    },\n  };\n}) satisfies IntegrationFn;\n\nexport const contextLinesIntegration = defineIntegration(_contextLinesIntegration);\n\n/**\n * Add node modules / packages to the event.\n * @deprecated Use `contextLinesIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const ContextLines = convertIntegrationFnToClass(INTEGRATION_NAME, contextLinesIntegration) as IntegrationClass<\n  Integration & { processEvent: (event: Event) => Promise<Event> }\n> & { new (options?: { frameContextLines?: number }): Integration };\n\nasync function addSourceContext(event: Event, contextLines: number): Promise<Event> {\n  // keep a lookup map of which files we've already enqueued to read,\n  // so we don't enqueue the same file multiple times which would cause multiple i/o reads\n  const enqueuedReadSourceFileTasks: Record<string, number> = {};\n  const readSourceFileTasks: Promise<string[] | null>[] = [];\n\n  if (contextLines > 0 && event.exception?.values) {\n    for (const exception of event.exception.values) {\n      if (!exception.stacktrace?.frames) {\n        continue;\n      }\n\n      // We want to iterate in reverse order as calling cache.get will bump the file in our LRU cache.\n      // This ends up prioritizes source context for frames at the top of the stack instead of the bottom.\n      for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {\n        const frame = exception.stacktrace.frames[i];\n        // Call cache.get to bump the file to the top of the cache and ensure we have not already\n        // enqueued a read operation for this filename\n        if (frame.filename && !enqueuedReadSourceFileTasks[frame.filename] && !FILE_CONTENT_CACHE.get(frame.filename)) {\n          readSourceFileTasks.push(_readSourceFile(frame.filename));\n          enqueuedReadSourceFileTasks[frame.filename] = 1;\n        }\n      }\n    }\n  }\n\n  // check if files to read > 0, if so, await all of them to be read before adding source contexts.\n  // Normally, Promise.all here could be short circuited if one of the promises rejects, but we\n  // are guarding from that by wrapping the i/o read operation in a try/catch.\n  if (readSourceFileTasks.length > 0) {\n    await Promise.all(readSourceFileTasks);\n  }\n\n  // Perform the same loop as above, but this time we can assume all files are in the cache\n  // and attempt to add source context to frames.\n  if (contextLines > 0 && event.exception?.values) {\n    for (const exception of event.exception.values) {\n      if (exception.stacktrace && exception.stacktrace.frames) {\n        await addSourceContextToFrames(exception.stacktrace.frames, contextLines);\n      }\n    }\n  }\n\n  return event;\n}\n\n/** Adds context lines to frames */\nfunction addSourceContextToFrames(frames: StackFrame[], contextLines: number): void {\n  for (const frame of frames) {\n    // Only add context if we have a filename and it hasn't already been added\n    if (frame.filename && frame.context_line === undefined) {\n      const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);\n\n      if (sourceFileLines) {\n        try {\n          addContextToFrame(sourceFileLines, frame, contextLines);\n        } catch (e) {\n          // anomaly, being defensive in case\n          // unlikely to ever happen in practice but can definitely happen in theory\n        }\n      }\n    }\n  }\n}\n\n// eslint-disable-next-line deprecation/deprecation\nexport type ContextLines = typeof ContextLines;\n\n/**\n * Reads file contents and caches them in a global LRU cache.\n * If reading fails, mark the file as null in the cache so we don't try again.\n *\n * @param filename filepath to read content from.\n */\nasync function _readSourceFile(filename: string): Promise<string[] | null> {\n  const cachedFile = FILE_CONTENT_CACHE.get(filename);\n\n  // We have already attempted to read this file and failed, do not try again\n  if (cachedFile === null) {\n    return null;\n  }\n\n  // We have a cache hit, return it\n  if (cachedFile !== undefined) {\n    return cachedFile;\n  }\n\n  // Guard from throwing if readFile fails, this enables us to use Promise.all and\n  // not have it short circuiting if one of the promises rejects + since context lines are added\n  // on a best effort basis, we want to throw here anyways.\n\n  // If we made it to here, it means that our file is not cache nor marked as failed, so attempt to read it\n  let content: string[] | null = null;\n  try {\n    const rawFileContents = await readTextFileAsync(filename);\n    content = rawFileContents.split('\\n');\n  } catch (_) {\n    // if we fail, we will mark the file as null in the cache and short circuit next time we try to read it\n  }\n\n  FILE_CONTENT_CACHE.set(filename, content);\n  return content;\n}\n"],"mappings":";;;;AAKA,MAAMA,kBAAA,GAAqB,IAAIC,MAAM,CAA0B,GAAG,CAAC;AACnE,MAAMC,wBAAA,GAA2B,CAAC;AAClC,MAAMC,gBAAA,GAAmB,cAAc;;AAEvC;AACA,SAASC,iBAAiBA,CAACC,IAAI,EAA2B;EACxD,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtCC,QAAQ,CAACJ,IAAI,EAAE,MAAM,EAAE,CAACK,GAAG,EAAEC,IAAI,KAAK;MACpC,IAAID,GAAG,EAAEF,MAAM,CAACE,GAAG,CAAC,MACfH,OAAO,CAACI,IAAI,CAAC;IACxB,CAAK,CAAC;EACN,CAAG,CAAC;AACJ;AAoBA,MAAMC,wBAAA,GAA4BA,CAACC,OAAO,GAAwB,EAAE,KAAK;EACvE,MAAMC,YAAA,GAAeD,OAAO,CAACE,iBAAA,KAAsBC,SAAA,GAAYH,OAAO,CAACE,iBAAA,GAAoBb,wBAAwB;EAEnH,OAAO;IACLe,IAAI,EAAEd,gBAAgB;IAC1B;IACIe,SAASA,CAAA,EAAG,CAAE;IAAA;IACdC,YAAYA,CAACC,KAAK,EAAE;MAClB,OAAOC,gBAAgB,CAACD,KAAK,EAAEN,YAAY,CAAC;IAC7C;EACL,CAAG;AACH,CAAC;MAEYQ,uBAAwB,GAAEC,iBAAiB,CAACX,wBAAwB,CAAC;;AAElF;;;;AAIA;AACO,MAAMY,YAAA,GAAeC,2BAA2B,CAACtB,gBAAgB,EAAEmB,uBAAuB;AAIjG,eAAeD,gBAAgBA,CAACD,KAAK,EAASN,YAAY,EAA0B;EACpF;EACA;EACE,MAAMY,2BAAA,GAAsD,EAAE;EAC9D,MAAMC,mBAAA,GAAkD,EAAE;EAE1D,IAAIb,YAAA,GAAe,KAAKc,cAAA,EAAAR,KAAK,EAAC,UAAAS,EAAA,IAAAA,EAAA,CAAAC,SAAS,EAAE,kBAAAC,EAAA,IAAAA,EAAA,CAAAC,MAAA,EAAM,EAAE;IAC/C,KAAK,MAAMF,SAAU,IAAGV,KAAK,CAACU,SAAS,CAACE,MAAM,EAAE;MAC9C,IAAI,CAACJ,cAAA,EAAAE,SAAS,YAAAG,EAAA,IAAAA,EAAA,CAACC,UAAU,oBAAAC,EAAA,IAAAA,EAAA,CAAEC,MAAA,EAAM,EAAE;QACjC;MACF;;MAEN;MACA;MACM,KAAK,IAAIC,CAAA,GAAIP,SAAS,CAACI,UAAU,CAACE,MAAM,CAACE,MAAA,GAAS,CAAC,EAAED,CAAA,IAAK,CAAC,EAAEA,CAAC,EAAE,EAAE;QAChE,MAAME,KAAM,GAAET,SAAS,CAACI,UAAU,CAACE,MAAM,CAACC,CAAC,CAAC;QACpD;QACA;QACQ,IAAIE,KAAK,CAACC,QAAA,IAAY,CAACd,2BAA2B,CAACa,KAAK,CAACC,QAAQ,KAAK,CAACxC,kBAAkB,CAACyC,GAAG,CAACF,KAAK,CAACC,QAAQ,CAAC,EAAE;UAC7Gb,mBAAmB,CAACe,IAAI,CAACC,eAAe,CAACJ,KAAK,CAACC,QAAQ,CAAC,CAAC;UACzDd,2BAA2B,CAACa,KAAK,CAACC,QAAQ,IAAI,CAAC;QACjD;MACF;IACF;EACF;;EAEF;EACA;EACA;EACE,IAAIb,mBAAmB,CAACW,MAAO,GAAE,CAAC,EAAE;IAClC,MAAMhC,OAAO,CAACsC,GAAG,CAACjB,mBAAmB,CAAC;EACxC;;EAEF;EACA;EACE,IAAIb,YAAA,GAAe,KAAKc,cAAA,EAAAR,KAAK,EAAC,UAAAyB,EAAA,IAAAA,EAAA,CAAAf,SAAS,EAAE,kBAAAgB,EAAA,IAAAA,EAAA,CAAAd,MAAA,EAAM,EAAE;IAC/C,KAAK,MAAMF,SAAU,IAAGV,KAAK,CAACU,SAAS,CAACE,MAAM,EAAE;MAC9C,IAAIF,SAAS,CAACI,UAAA,IAAcJ,SAAS,CAACI,UAAU,CAACE,MAAM,EAAE;QACvD,MAAMW,wBAAwB,CAACjB,SAAS,CAACI,UAAU,CAACE,MAAM,EAAEtB,YAAY,CAAC;MAC3E;IACF;EACF;EAEA,OAAOM,KAAK;AACd;;AAEA;AACA,SAAS2B,wBAAwBA,CAACX,MAAM,EAAgBtB,YAAY,EAAgB;EAClF,KAAK,MAAMyB,KAAM,IAAGH,MAAM,EAAE;IAC9B;IACI,IAAIG,KAAK,CAACC,QAAA,IAAYD,KAAK,CAACS,YAAA,KAAiBhC,SAAS,EAAE;MACtD,MAAMiC,eAAgB,GAAEjD,kBAAkB,CAACyC,GAAG,CAACF,KAAK,CAACC,QAAQ,CAAC;MAE9D,IAAIS,eAAe,EAAE;QACnB,IAAI;UACFC,iBAAiB,CAACD,eAAe,EAAEV,KAAK,EAAEzB,YAAY,CAAC;QACvD,SAAOqC,CAAC,EAAE;UACpB;UACA;QAAA;MAEM;IACF;EACF;AACF;;AAEA;;AAGA;;;;;;AAMA,eAAeR,eAAeA,CAACH,QAAQ,EAAoC;EACzE,MAAMY,UAAA,GAAapD,kBAAkB,CAACyC,GAAG,CAACD,QAAQ,CAAC;;EAErD;EACE,IAAIY,UAAA,KAAe,IAAI,EAAE;IACvB,OAAO,IAAI;EACb;;EAEF;EACE,IAAIA,UAAA,KAAepC,SAAS,EAAE;IAC5B,OAAOoC,UAAU;EACnB;;EAEF;EACA;EACA;;EAEA;EACE,IAAIC,OAAA,GAA2B,IAAI;EACnC,IAAI;IACF,MAAMC,eAAA,GAAkB,MAAMlD,iBAAiB,CAACoC,QAAQ,CAAC;IACzDa,OAAA,GAAUC,eAAe,CAACC,KAAK,CAAC,IAAI,CAAC;EACrC,SAAOC,CAAC,EAAE;IACd;EAAA;EAGExD,kBAAkB,CAACyD,GAAG,CAACjB,QAAQ,EAAEa,OAAO,CAAC;EACzC,OAAOA,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}