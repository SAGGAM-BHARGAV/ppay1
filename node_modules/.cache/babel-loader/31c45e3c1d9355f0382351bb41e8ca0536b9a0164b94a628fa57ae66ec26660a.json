{"ast":null,"code":"import { _optionalChain, _optionalChainDelete } from '@sentry/utils';\nimport { URL } from 'url';\nimport { defineIntegration, convertIntegrationFnToClass, getGlobalScope, mergeScopeData, getIsolationScope, getCurrentScope } from '@sentry/core';\nimport { logger, GLOBAL_OBJ, dynamicRequire } from '@sentry/utils';\nimport { NODE_VERSION } from '../../nodeVersion.js';\nimport { base64WorkerScript } from './worker-script.js';\nconst DEFAULT_INTERVAL = 50;\nconst DEFAULT_HANG_THRESHOLD = 5000;\nfunction log(message, ...args) {\n  logger.log(`[ANR] ${message}`, ...args);\n}\nfunction globalWithScopeFetchFn() {\n  return GLOBAL_OBJ;\n}\n\n/** Fetches merged scope data */\nfunction getScopeData() {\n  const scope = getGlobalScope().getScopeData();\n  mergeScopeData(scope, getIsolationScope().getScopeData());\n  mergeScopeData(scope, getCurrentScope().getScopeData());\n\n  // We remove attachments because they likely won't serialize well as json\n  scope.attachments = [];\n  // We can't serialize event processor functions\n  scope.eventProcessors = [];\n  return scope;\n}\n\n/**\n * We need to use dynamicRequire because worker_threads is not available in node < v12 and webpack error will when\n * targeting those versions\n */\nfunction getWorkerThreads() {\n  return dynamicRequire(module, 'worker_threads');\n}\n\n/**\n * Gets contexts by calling all event processors. This relies on being called after all integrations are setup\n */\nasync function getContexts(client) {\n  let event = {\n    message: 'ANR'\n  };\n  const eventHint = {};\n  for (const processor of client.getEventProcessors()) {\n    if (event === null) break;\n    event = await processor(event, eventHint);\n  }\n  return _optionalChain([event, 'optionalAccess', _2 => _2.contexts]) || {};\n}\nconst INTEGRATION_NAME = 'Anr';\nconst _anrIntegration = (options = {}) => {\n  if (NODE_VERSION.major < 16 || NODE_VERSION.major === 16 && NODE_VERSION.minor < 17) {\n    throw new Error('ANR detection requires Node 16.17.0 or later');\n  }\n  let worker;\n  let client;\n\n  // Hookup the scope fetch function to the global object so that it can be called from the worker thread via the\n  // debugger when it pauses\n  const gbl = globalWithScopeFetchFn();\n  gbl.__SENTRY_GET_SCOPES__ = getScopeData;\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {},\n    // eslint-disable-line @typescript-eslint/no-empty-function\n    startWorker: () => {\n      if (worker) {\n        return;\n      }\n      if (client) {\n        worker = _startWorker(client, options);\n      }\n    },\n    stopWorker: () => {\n      if (worker) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        worker.then(stop => {\n          stop();\n          worker = undefined;\n        });\n      }\n    },\n    setup(initClient) {\n      client = initClient;\n\n      // setImmediate is used to ensure that all other integrations have had their setup called first.\n      // This allows us to call into all integrations to fetch the full context\n      setImmediate(() => this.startWorker());\n    }\n  };\n};\nconst anrIntegration = defineIntegration(_anrIntegration);\n\n/**\n * Starts a thread to detect App Not Responding (ANR) events\n *\n * ANR detection requires Node 16.17.0 or later\n *\n * @deprecated Use `anrIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nconst Anr = convertIntegrationFnToClass(INTEGRATION_NAME, anrIntegration);\n\n// eslint-disable-next-line deprecation/deprecation\n\n/**\n * Starts the ANR worker thread\n */\nasync function _startWorker(client, integrationOptions) {\n  const dsn = client.getDsn();\n  if (!dsn) {\n    return () => {\n      //\n    };\n  }\n  const contexts = await getContexts(client);\n\n  // These will not be accurate if sent later from the worker thread\n  _optionalChainDelete([contexts, 'access', _3 => _3.app, 'optionalAccess', _4 => delete _4.app_memory]);\n  _optionalChainDelete([contexts, 'access', _5 => _5.device, 'optionalAccess', _6 => delete _6.free_memory]);\n  const initOptions = client.getOptions();\n  const sdkMetadata = client.getSdkMetadata() || {};\n  if (sdkMetadata.sdk) {\n    sdkMetadata.sdk.integrations = initOptions.integrations.map(i => i.name);\n  }\n  const options = {\n    debug: logger.isEnabled(),\n    dsn,\n    environment: initOptions.environment || 'production',\n    release: initOptions.release,\n    dist: initOptions.dist,\n    sdkMetadata,\n    appRootPath: integrationOptions.appRootPath,\n    pollInterval: integrationOptions.pollInterval || DEFAULT_INTERVAL,\n    anrThreshold: integrationOptions.anrThreshold || DEFAULT_HANG_THRESHOLD,\n    captureStackTrace: !!integrationOptions.captureStackTrace,\n    staticTags: integrationOptions.staticTags || {},\n    contexts\n  };\n  if (options.captureStackTrace) {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const inspector = require('inspector');\n    if (!inspector.url()) {\n      inspector.open(0);\n    }\n  }\n  const {\n    Worker\n  } = getWorkerThreads();\n  const worker = new Worker(new URL(`data:application/javascript;base64,${base64WorkerScript}`), {\n    workerData: options\n  });\n  process.on('exit', () => {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    worker.terminate();\n  });\n  const timer = setInterval(() => {\n    try {\n      const currentSession = getCurrentScope().getSession();\n      // We need to copy the session object and remove the toJSON method so it can be sent to the worker\n      // serialized without making it a SerializedSession\n      const session = currentSession ? {\n        ...currentSession,\n        toJSON: undefined\n      } : undefined;\n      // message the worker to tell it the main event loop is still running\n      worker.postMessage({\n        session\n      });\n    } catch (_) {\n      //\n    }\n  }, options.pollInterval);\n  // Timer should not block exit\n  timer.unref();\n  worker.on('message', msg => {\n    if (msg === 'session-ended') {\n      log('ANR event sent from ANR worker. Clearing session in this thread.');\n      getCurrentScope().setSession(undefined);\n    }\n  });\n  worker.once('error', err => {\n    clearInterval(timer);\n    log('ANR worker error', err);\n  });\n  worker.once('exit', code => {\n    clearInterval(timer);\n    log('ANR worker exit', code);\n  });\n\n  // Ensure this thread can't block app exit\n  worker.unref();\n  return () => {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    worker.terminate();\n    clearInterval(timer);\n  };\n}\nexport { Anr, anrIntegration };","map":{"version":3,"names":["DEFAULT_INTERVAL","DEFAULT_HANG_THRESHOLD","log","message","args","logger","globalWithScopeFetchFn","GLOBAL_OBJ","getScopeData","scope","getGlobalScope","mergeScopeData","getIsolationScope","getCurrentScope","attachments","eventProcessors","getWorkerThreads","dynamicRequire","module","getContexts","client","event","eventHint","processor","getEventProcessors","_optionalChain","_2","contexts","INTEGRATION_NAME","_anrIntegration","options","NODE_VERSION","major","minor","Error","worker","gbl","__SENTRY_GET_SCOPES__","name","setupOnce","startWorker","_startWorker","stopWorker","then","stop","undefined","setup","initClient","setImmediate","anrIntegration","defineIntegration","Anr","convertIntegrationFnToClass","integrationOptions","dsn","getDsn","_optionalChainDelete","_3","app","_4","app_memory","_5","device","_6","free_memory","initOptions","getOptions","sdkMetadata","getSdkMetadata","sdk","integrations","map","i","debug","isEnabled","environment","release","dist","appRootPath","pollInterval","anrThreshold","captureStackTrace","staticTags","inspector","require","url","open","Worker","URL","base64WorkerScript","workerData","process","on","terminate","timer","setInterval","currentSession","getSession","session","toJSON","postMessage","_","unref","msg","setSession","once","err","clearInterval","code"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\integrations\\anr\\index.ts"],"sourcesContent":["// TODO (v8): This import can be removed once we only support Node with global URL\nimport { URL } from 'url';\nimport {\n  convertIntegrationFnToClass,\n  defineIntegration,\n  getCurrentScope,\n  getGlobalScope,\n  getIsolationScope,\n  mergeScopeData,\n} from '@sentry/core';\nimport type {\n  Client,\n  Contexts,\n  Event,\n  EventHint,\n  Integration,\n  IntegrationClass,\n  IntegrationFn,\n  IntegrationFnResult,\n  ScopeData,\n} from '@sentry/types';\nimport { GLOBAL_OBJ, dynamicRequire, logger } from '@sentry/utils';\nimport type { Worker, WorkerOptions } from 'worker_threads';\nimport type { NodeClient } from '../../client';\nimport { NODE_VERSION } from '../../nodeVersion';\nimport type { AnrIntegrationOptions, WorkerStartData } from './common';\nimport { base64WorkerScript } from './worker-script';\n\nconst DEFAULT_INTERVAL = 50;\nconst DEFAULT_HANG_THRESHOLD = 5000;\n\ntype WorkerNodeV14 = Worker & { new (filename: string | URL, options?: WorkerOptions): Worker };\n\ntype WorkerThreads = {\n  Worker: WorkerNodeV14;\n};\n\nfunction log(message: string, ...args: unknown[]): void {\n  logger.log(`[ANR] ${message}`, ...args);\n}\n\nfunction globalWithScopeFetchFn(): typeof GLOBAL_OBJ & { __SENTRY_GET_SCOPES__?: () => ScopeData } {\n  return GLOBAL_OBJ;\n}\n\n/** Fetches merged scope data */\nfunction getScopeData(): ScopeData {\n  const scope = getGlobalScope().getScopeData();\n  mergeScopeData(scope, getIsolationScope().getScopeData());\n  mergeScopeData(scope, getCurrentScope().getScopeData());\n\n  // We remove attachments because they likely won't serialize well as json\n  scope.attachments = [];\n  // We can't serialize event processor functions\n  scope.eventProcessors = [];\n\n  return scope;\n}\n\n/**\n * We need to use dynamicRequire because worker_threads is not available in node < v12 and webpack error will when\n * targeting those versions\n */\nfunction getWorkerThreads(): WorkerThreads {\n  return dynamicRequire(module, 'worker_threads');\n}\n\n/**\n * Gets contexts by calling all event processors. This relies on being called after all integrations are setup\n */\nasync function getContexts(client: NodeClient): Promise<Contexts> {\n  let event: Event | null = { message: 'ANR' };\n  const eventHint: EventHint = {};\n\n  for (const processor of client.getEventProcessors()) {\n    if (event === null) break;\n    event = await processor(event, eventHint);\n  }\n\n  return event?.contexts || {};\n}\n\ninterface InspectorApi {\n  open: (port: number) => void;\n  url: () => string | undefined;\n}\n\nconst INTEGRATION_NAME = 'Anr';\n\ntype AnrInternal = { startWorker: () => void; stopWorker: () => void };\n\nconst _anrIntegration = ((options: Partial<AnrIntegrationOptions> = {}) => {\n  if (NODE_VERSION.major < 16 || (NODE_VERSION.major === 16 && NODE_VERSION.minor < 17)) {\n    throw new Error('ANR detection requires Node 16.17.0 or later');\n  }\n\n  let worker: Promise<() => void> | undefined;\n  let client: NodeClient | undefined;\n\n  // Hookup the scope fetch function to the global object so that it can be called from the worker thread via the\n  // debugger when it pauses\n  const gbl = globalWithScopeFetchFn();\n  gbl.__SENTRY_GET_SCOPES__ = getScopeData;\n\n  return {\n    name: INTEGRATION_NAME,\n    // TODO v8: Remove this\n    setupOnce() {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    startWorker: () => {\n      if (worker) {\n        return;\n      }\n\n      if (client) {\n        worker = _startWorker(client, options);\n      }\n    },\n    stopWorker: () => {\n      if (worker) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        worker.then(stop => {\n          stop();\n          worker = undefined;\n        });\n      }\n    },\n    setup(initClient: NodeClient) {\n      client = initClient;\n\n      // setImmediate is used to ensure that all other integrations have had their setup called first.\n      // This allows us to call into all integrations to fetch the full context\n      setImmediate(() => this.startWorker());\n    },\n  } as IntegrationFnResult & AnrInternal;\n}) satisfies IntegrationFn;\n\ntype AnrReturn = (options?: Partial<AnrIntegrationOptions>) => IntegrationFnResult & AnrInternal;\n\nexport const anrIntegration = defineIntegration(_anrIntegration) as AnrReturn;\n\n/**\n * Starts a thread to detect App Not Responding (ANR) events\n *\n * ANR detection requires Node 16.17.0 or later\n *\n * @deprecated Use `anrIntegration()` instead.\n */\n// eslint-disable-next-line deprecation/deprecation\nexport const Anr = convertIntegrationFnToClass(INTEGRATION_NAME, anrIntegration) as IntegrationClass<\n  Integration & { setup: (client: NodeClient) => void }\n> & {\n  new (options?: Partial<AnrIntegrationOptions>): Integration & { setup(client: Client): void };\n};\n\n// eslint-disable-next-line deprecation/deprecation\nexport type Anr = typeof Anr;\n\n/**\n * Starts the ANR worker thread\n */\nasync function _startWorker(\n  client: NodeClient,\n  integrationOptions: Partial<AnrIntegrationOptions>,\n): Promise<() => void> {\n  const dsn = client.getDsn();\n\n  if (!dsn) {\n    return () => {\n      //\n    };\n  }\n\n  const contexts = await getContexts(client);\n\n  // These will not be accurate if sent later from the worker thread\n  delete contexts.app?.app_memory;\n  delete contexts.device?.free_memory;\n\n  const initOptions = client.getOptions();\n\n  const sdkMetadata = client.getSdkMetadata() || {};\n  if (sdkMetadata.sdk) {\n    sdkMetadata.sdk.integrations = initOptions.integrations.map(i => i.name);\n  }\n\n  const options: WorkerStartData = {\n    debug: logger.isEnabled(),\n    dsn,\n    environment: initOptions.environment || 'production',\n    release: initOptions.release,\n    dist: initOptions.dist,\n    sdkMetadata,\n    appRootPath: integrationOptions.appRootPath,\n    pollInterval: integrationOptions.pollInterval || DEFAULT_INTERVAL,\n    anrThreshold: integrationOptions.anrThreshold || DEFAULT_HANG_THRESHOLD,\n    captureStackTrace: !!integrationOptions.captureStackTrace,\n    staticTags: integrationOptions.staticTags || {},\n    contexts,\n  };\n\n  if (options.captureStackTrace) {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const inspector: InspectorApi = require('inspector');\n    if (!inspector.url()) {\n      inspector.open(0);\n    }\n  }\n\n  const { Worker } = getWorkerThreads();\n\n  const worker = new Worker(new URL(`data:application/javascript;base64,${base64WorkerScript}`), {\n    workerData: options,\n  });\n\n  process.on('exit', () => {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    worker.terminate();\n  });\n\n  const timer = setInterval(() => {\n    try {\n      const currentSession = getCurrentScope().getSession();\n      // We need to copy the session object and remove the toJSON method so it can be sent to the worker\n      // serialized without making it a SerializedSession\n      const session = currentSession ? { ...currentSession, toJSON: undefined } : undefined;\n      // message the worker to tell it the main event loop is still running\n      worker.postMessage({ session });\n    } catch (_) {\n      //\n    }\n  }, options.pollInterval);\n  // Timer should not block exit\n  timer.unref();\n\n  worker.on('message', (msg: string) => {\n    if (msg === 'session-ended') {\n      log('ANR event sent from ANR worker. Clearing session in this thread.');\n      getCurrentScope().setSession(undefined);\n    }\n  });\n\n  worker.once('error', (err: Error) => {\n    clearInterval(timer);\n    log('ANR worker error', err);\n  });\n\n  worker.once('exit', (code: number) => {\n    clearInterval(timer);\n    log('ANR worker exit', code);\n  });\n\n  // Ensure this thread can't block app exit\n  worker.unref();\n\n  return () => {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    worker.terminate();\n    clearInterval(timer);\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}