{"ast":null,"code":"import { _nullishCoalesce } from '@sentry/utils';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { Readable } from 'stream';\nimport { URL } from 'url';\nimport { createGzip } from 'zlib';\nimport { createTransport } from '@sentry/core';\nimport { consoleSandbox } from '@sentry/utils';\nimport { HttpsProxyAgent } from '../proxy/index.js';\n\n// Estimated maximum size for reasonable standalone event\nconst GZIP_THRESHOLD = 1024 * 32;\n\n/**\n * Gets a stream from a Uint8Array or string\n * Readable.from is ideal but was added in node.js v12.3.0 and v10.17.0\n */\nfunction streamFromBody(body) {\n  return new Readable({\n    read() {\n      this.push(body);\n      this.push(null);\n    }\n  });\n}\n\n/**\n * Creates a Transport that uses native the native 'http' and 'https' modules to send events to Sentry.\n */\nfunction makeNodeTransport(options) {\n  let urlSegments;\n  try {\n    urlSegments = new URL(options.url);\n  } catch (e) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn('[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.');\n    });\n    return createTransport(options, () => Promise.resolve({}));\n  }\n  const isHttps = urlSegments.protocol === 'https:';\n\n  // Proxy prioritization: http => `options.proxy` | `process.env.http_proxy`\n  // Proxy prioritization: https => `options.proxy` | `process.env.https_proxy` | `process.env.http_proxy`\n  const proxy = applyNoProxyOption(urlSegments, options.proxy || (isHttps ? process.env.https_proxy : undefined) || process.env.http_proxy);\n  const nativeHttpModule = isHttps ? https : http;\n  const keepAlive = options.keepAlive === undefined ? false : options.keepAlive;\n\n  // TODO(v7): Evaluate if we can set keepAlive to true. This would involve testing for memory leaks in older node\n  // versions(>= 8) as they had memory leaks when using it: #2555\n  const agent = proxy ? new HttpsProxyAgent(proxy) : new nativeHttpModule.Agent({\n    keepAlive,\n    maxSockets: 30,\n    timeout: 2000\n  });\n  const requestExecutor = createRequestExecutor(options, _nullishCoalesce(options.httpModule, () => nativeHttpModule), agent);\n  return createTransport(options, requestExecutor);\n}\n\n/**\n * Honors the `no_proxy` env variable with the highest priority to allow for hosts exclusion.\n *\n * @param transportUrl The URL the transport intends to send events to.\n * @param proxy The client configured proxy.\n * @returns A proxy the transport should use.\n */\nfunction applyNoProxyOption(transportUrlSegments, proxy) {\n  const {\n    no_proxy\n  } = process.env;\n  const urlIsExemptFromProxy = no_proxy && no_proxy.split(',').some(exemption => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption));\n  if (urlIsExemptFromProxy) {\n    return undefined;\n  } else {\n    return proxy;\n  }\n}\n\n/**\n * Creates a RequestExecutor to be used with `createTransport`.\n */\nfunction createRequestExecutor(options, httpModule, agent) {\n  const {\n    hostname,\n    pathname,\n    port,\n    protocol,\n    search\n  } = new URL(options.url);\n  return function makeRequest(request) {\n    return new Promise((resolve, reject) => {\n      let body = streamFromBody(request.body);\n      const headers = {\n        ...options.headers\n      };\n      if (request.body.length > GZIP_THRESHOLD) {\n        headers['content-encoding'] = 'gzip';\n        body = body.pipe(createGzip());\n      }\n      const req = httpModule.request({\n        method: 'POST',\n        agent,\n        headers,\n        hostname,\n        path: `${pathname}${search}`,\n        port,\n        protocol,\n        ca: options.caCerts\n      }, res => {\n        res.on('data', () => {\n          // Drain socket\n        });\n        res.on('end', () => {\n          // Drain socket\n        });\n        res.setEncoding('utf8');\n\n        // \"Key-value pairs of header names and values. Header names are lower-cased.\"\n        // https://nodejs.org/api/http.html#http_message_headers\n        const retryAfterHeader = _nullishCoalesce(res.headers['retry-after'], () => null);\n        const rateLimitsHeader = _nullishCoalesce(res.headers['x-sentry-rate-limits'], () => null);\n        resolve({\n          statusCode: res.statusCode,\n          headers: {\n            'retry-after': retryAfterHeader,\n            'x-sentry-rate-limits': Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader\n          }\n        });\n      });\n      req.on('error', reject);\n      body.pipe(req);\n    });\n  };\n}\nexport { makeNodeTransport };","map":{"version":3,"names":["GZIP_THRESHOLD","streamFromBody","body","Readable","read","push","makeNodeTransport","options","urlSegments","URL","url","e","consoleSandbox","console","warn","createTransport","Promise","resolve","isHttps","protocol","proxy","applyNoProxyOption","process","env","https_proxy","undefined","http_proxy","nativeHttpModule","https","http","keepAlive","agent","HttpsProxyAgent","Agent","maxSockets","timeout","requestExecutor","createRequestExecutor","_nullishCoalesce","httpModule","transportUrlSegments","no_proxy","urlIsExemptFromProxy","split","some","exemption","host","endsWith","hostname","pathname","port","search","makeRequest","request","reject","headers","length","pipe","createGzip","req","method","path","ca","caCerts","res","on","setEncoding","retryAfterHeader","rateLimitsHeader","statusCode","Array","isArray"],"sources":["C:\\Users\\kotha\\OneDrive\\Desktop\\3\\vbn\\node_modules\\@sentry\\src\\transports\\http.ts"],"sourcesContent":["import * as http from 'http';\nimport * as https from 'https';\nimport { Readable } from 'stream';\nimport { URL } from 'url';\nimport { createGzip } from 'zlib';\nimport { createTransport } from '@sentry/core';\nimport type {\n  BaseTransportOptions,\n  Transport,\n  TransportMakeRequestResponse,\n  TransportRequest,\n  TransportRequestExecutor,\n} from '@sentry/types';\nimport { consoleSandbox } from '@sentry/utils';\nimport { HttpsProxyAgent } from '../proxy';\n\nimport type { HTTPModule } from './http-module';\n\nexport interface NodeTransportOptions extends BaseTransportOptions {\n  /** Define custom headers */\n  headers?: Record<string, string>;\n  /** Set a proxy that should be used for outbound requests. */\n  proxy?: string;\n  /** HTTPS proxy CA certificates */\n  caCerts?: string | Buffer | Array<string | Buffer>;\n  /** Custom HTTP module. Defaults to the native 'http' and 'https' modules. */\n  httpModule?: HTTPModule;\n  /** Allow overriding connection keepAlive, defaults to false */\n  keepAlive?: boolean;\n}\n\n// Estimated maximum size for reasonable standalone event\nconst GZIP_THRESHOLD = 1024 * 32;\n\n/**\n * Gets a stream from a Uint8Array or string\n * Readable.from is ideal but was added in node.js v12.3.0 and v10.17.0\n */\nfunction streamFromBody(body: Uint8Array | string): Readable {\n  return new Readable({\n    read() {\n      this.push(body);\n      this.push(null);\n    },\n  });\n}\n\n/**\n * Creates a Transport that uses native the native 'http' and 'https' modules to send events to Sentry.\n */\nexport function makeNodeTransport(options: NodeTransportOptions): Transport {\n  let urlSegments: URL;\n\n  try {\n    urlSegments = new URL(options.url);\n  } catch (e) {\n    consoleSandbox(() => {\n      // eslint-disable-next-line no-console\n      console.warn(\n        '[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.',\n      );\n    });\n    return createTransport(options, () => Promise.resolve({}));\n  }\n\n  const isHttps = urlSegments.protocol === 'https:';\n\n  // Proxy prioritization: http => `options.proxy` | `process.env.http_proxy`\n  // Proxy prioritization: https => `options.proxy` | `process.env.https_proxy` | `process.env.http_proxy`\n  const proxy = applyNoProxyOption(\n    urlSegments,\n    options.proxy || (isHttps ? process.env.https_proxy : undefined) || process.env.http_proxy,\n  );\n\n  const nativeHttpModule = isHttps ? https : http;\n  const keepAlive = options.keepAlive === undefined ? false : options.keepAlive;\n\n  // TODO(v7): Evaluate if we can set keepAlive to true. This would involve testing for memory leaks in older node\n  // versions(>= 8) as they had memory leaks when using it: #2555\n  const agent = proxy\n    ? (new HttpsProxyAgent(proxy) as http.Agent)\n    : new nativeHttpModule.Agent({ keepAlive, maxSockets: 30, timeout: 2000 });\n\n  const requestExecutor = createRequestExecutor(options, options.httpModule ?? nativeHttpModule, agent);\n  return createTransport(options, requestExecutor);\n}\n\n/**\n * Honors the `no_proxy` env variable with the highest priority to allow for hosts exclusion.\n *\n * @param transportUrl The URL the transport intends to send events to.\n * @param proxy The client configured proxy.\n * @returns A proxy the transport should use.\n */\nfunction applyNoProxyOption(transportUrlSegments: URL, proxy: string | undefined): string | undefined {\n  const { no_proxy } = process.env;\n\n  const urlIsExemptFromProxy =\n    no_proxy &&\n    no_proxy\n      .split(',')\n      .some(\n        exemption => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption),\n      );\n\n  if (urlIsExemptFromProxy) {\n    return undefined;\n  } else {\n    return proxy;\n  }\n}\n\n/**\n * Creates a RequestExecutor to be used with `createTransport`.\n */\nfunction createRequestExecutor(\n  options: NodeTransportOptions,\n  httpModule: HTTPModule,\n  agent: http.Agent,\n): TransportRequestExecutor {\n  const { hostname, pathname, port, protocol, search } = new URL(options.url);\n  return function makeRequest(request: TransportRequest): Promise<TransportMakeRequestResponse> {\n    return new Promise((resolve, reject) => {\n      let body = streamFromBody(request.body);\n\n      const headers: Record<string, string> = { ...options.headers };\n\n      if (request.body.length > GZIP_THRESHOLD) {\n        headers['content-encoding'] = 'gzip';\n        body = body.pipe(createGzip());\n      }\n\n      const req = httpModule.request(\n        {\n          method: 'POST',\n          agent,\n          headers,\n          hostname,\n          path: `${pathname}${search}`,\n          port,\n          protocol,\n          ca: options.caCerts,\n        },\n        res => {\n          res.on('data', () => {\n            // Drain socket\n          });\n\n          res.on('end', () => {\n            // Drain socket\n          });\n\n          res.setEncoding('utf8');\n\n          // \"Key-value pairs of header names and values. Header names are lower-cased.\"\n          // https://nodejs.org/api/http.html#http_message_headers\n          const retryAfterHeader = res.headers['retry-after'] ?? null;\n          const rateLimitsHeader = res.headers['x-sentry-rate-limits'] ?? null;\n\n          resolve({\n            statusCode: res.statusCode,\n            headers: {\n              'retry-after': retryAfterHeader,\n              'x-sentry-rate-limits': Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader,\n            },\n          });\n        },\n      );\n\n      req.on('error', reject);\n      body.pipe(req);\n    });\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}